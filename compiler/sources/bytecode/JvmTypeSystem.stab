/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.io;
using java.lang;
using java.util;
using java.util.zip;
using stab.query;
using stab.tools.helpers;

package stab.tools.bytecode {

    public class JvmTypeSystem {
        private JvmTypeSystem parent;
        private HashMap<String, File> classFiles;
		private HashMap<String, ZipFile> jarClasses;
        private ArrayList<String> allClassNames;
        private HashMap<String, JvmTypeInfo> typeInfos;
		private HashMap<JvmTypeInfo, ArrayList<JvmTypeInfo>> constructedGenericTypes;
        private HashMap<JvmMethodInfo, ArrayList<JvmMethodInfo>> constructedGenericMethods;
        
        private JvmTypeInfo objectType;
        private JvmTypeInfo stringType;
        private JvmTypeInfo classType;
        private JvmTypeInfo unboundedClassType;

        public JvmTypeSystem(String[] classPath) {
            this.classFiles = new HashMap<String, File>(128);
            this.jarClasses = new HashMap<String, ZipFile>(0x5000);
            this.allClassNames = new ArrayList<String>();
            this.typeInfos = new HashMap<String, JvmTypeInfo>();
			this.constructedGenericTypes = new HashMap<JvmTypeInfo, ArrayList<JvmTypeInfo>>();
			this.constructedGenericMethods = new HashMap<JvmMethodInfo, ArrayList<JvmMethodInfo>>();
            
            initializeBootClasses();
            
            foreach (var path in classPath) {
                explorePath(path);
            }
        }
        
        public JvmTypeSystem(String[] classPath, JvmTypeSystem parent) {
            this.classFiles = new HashMap<String, File>(128);
            this.jarClasses = new HashMap<String, ZipFile>(128);
            this.allClassNames = new ArrayList<String>();
            this.typeInfos = new HashMap<String, JvmTypeInfo>();
			this.constructedGenericTypes = new HashMap<JvmTypeInfo, ArrayList<JvmTypeInfo>>();
			this.constructedGenericMethods = new HashMap<JvmMethodInfo, ArrayList<JvmMethodInfo>>();
            this.parent = parent;
            
            foreach (var path in classPath) {
                explorePath(path);
            }
        }
        
        public Iterable<String> AllClassNames {
            get {
                if (parent == null) {
                    return allClassNames;
                } else {
                    return allClassNames.concat(parent.AllClassNames);
                }
            }
        }
        
		public Iterable<String> ClassNames {
			get {
				return allClassNames;
			}
		}
		
        public JvmTypeBuilder defineType(String name) {
            if (typeExists(name)) {
                throw new IllegalStateException("Type '" + name + "' already defined");
            }
            var result = new JvmTypeBuilder(null, name);
            typeInfos[name] = result;
            allClassNames.add(name);
            return result;
        }
        
        public boolean typeExists(String name) {
            return (parent != null && parent.typeExists(name)) || isLocalType(name);
        }
		
		protected boolean isLocalType(String name) {
			return typeInfos.containsKey(name) || classFiles.containsKey(name) || jarClasses.containsKey(name);
		}
        
        public JvmTypeInfo getType(String name) {
            var typeInfo = typeInfos[name];
            if (typeInfo != null) {
                return typeInfo;
            }
            var f = classFiles.remove(name);
			var zf = jarClasses.remove(name);
            if (f == null && zf == null) {
				if (parent == null) {
					throw new JvmTypeLoadException("Class not found: " + name, name);
				} else {
					return parent.getType(name);
				}
			}
			typeInfo = new ClassFileType(this, name, f, zf);
            return typeInfos[name] = typeInfo;
        }

        public JvmTypeInfo getGenericType(JvmTypeInfo type, Iterable<JvmTypeInfo> typeArguments) {
            return getGenericType(type, typeArguments, null);
        }

        JvmTypeInfo getGenericType(JvmTypeInfo type, Iterable<JvmTypeInfo> typeArguments, GenericParameterBindings scope) {
			if (parent == null || isLocalType(type.OriginalTypeDefinition.FullName)) {
				return getGenericTypeCore(type, typeArguments, scope);
			}
			foreach (var t in typeArguments) {
				if (isLocalType(t)) {
					return getGenericTypeCore(type, typeArguments, scope);
				}
			}
			return parent.getGenericType(type, typeArguments, scope);
		}
		
		private boolean isLocalType(JvmTypeInfo type) {
			switch (type.TypeKind) {
			case Reference:
				if (isLocalType(type.OriginalTypeDefinition.FullName)) {
					return true;
				}
				foreach (var arg in type.GenericArguments) {
					if (isLocalType(arg)) {
						return true;
					}
				}
				return false;
				
			case Array:
				return isLocalType(type.ElementType);
				
			case GenericParameter:
				return true;
				
			case LowerBoundedWildcard:
			case UpperBoundedWildcard:
				return isLocalType(type.WildcardBound);
				
			case UnboundedWildcard:
			default:
				return false;
			}
		}

        JvmTypeInfo getGenericTypeCore(JvmTypeInfo type, Iterable<JvmTypeInfo> typeArguments, GenericParameterBindings scope) {
            if (type.IsClosed) {
                throw new IllegalStateException();
            }
            if (typeArguments.sequenceEqual(type.GenericArguments)) {
                return type;
            }
            if (type.DeclaringType == null && !type.IsGenericTypeDefinition) {
                return getGenericType(type.OriginalTypeDefinition, typeArguments);
            }
			var constructedTypes = constructedGenericTypes[type];
            if (constructedTypes == null) {
                constructedTypes = new ArrayList<JvmTypeInfo>();
				constructedGenericTypes[type] = constructedTypes;
            } else {
                foreach (var t in constructedTypes) {
                    if (typeArguments.sequenceEqual(t.GenericArguments)) {
                        return t;
                    }
                }
            }
            var t = new ConstructedGenericType(this, type.DeclaringType, type, typeArguments, scope);
            constructedTypes.add(t);
            return t;
        }

		public JvmMethodInfo getGenericMethod(JvmMethodInfo method, Iterable<JvmTypeInfo> typeArguments) {
			if (parent == null || isLocalType(method.DeclaringType)) {
				return getGenericMethodCore(method, typeArguments);
			}
			foreach (var t in typeArguments) {
				if (isLocalType(t)) {
					return getGenericMethodCore(method, typeArguments);
				}
			}
			return parent.getGenericMethod(method, typeArguments);
		}
		
        private JvmMethodInfo getGenericMethodCore(JvmMethodInfo method, Iterable<JvmTypeInfo> typeArguments) {
            if (method.IsClosed) {
                throw new IllegalStateException();
            }
            if (typeArguments.sequenceEqual(method.GenericArguments)) {
                return method;
            }
			var constructedMethods = constructedGenericMethods[method];
            if (constructedMethods == null) {
                constructedMethods = new ArrayList<JvmMethodInfo>();
				constructedGenericMethods[method] = constructedMethods;
            } else {
                foreach (var m in constructedMethods) {
                    if (typeArguments.sequenceEqual(m.GenericArguments)) {
                        return m;
                    }
                }
            }
            var m = new ConstructedGenericMethod(this, method.DeclaringType, method, typeArguments, null);
            constructedMethods.add(m);
            return m;
        }
		
        public JvmTypeInfo ObjectType {
            get {
                if (parent == null) {
                    if (objectType == null) {
                        objectType = getType("java/lang/Object");
                    }
                    return objectType;
                } else {
                    return parent.ObjectType;
                }
            }
        }

        public JvmTypeInfo StringType {
            get {
                if (parent == null) {
                    if (stringType == null) {
                        stringType = getType("java/lang/String");
                    }
                    return stringType;
                } else {
                    return parent.StringType;
                }
            }
        }

        public JvmTypeInfo ClassType {
            get {
                if (parent == null) {
                    if (classType == null) {
                        classType = getType("java/lang/Class");
                    }
                    return classType;
                } else {
                    return parent.ClassType;
                }
            }
        }

        public JvmTypeInfo UnboundedClassType {
            get {
                if (parent == null) {
                    if (unboundedClassType == null) {
                        unboundedClassType = getGenericType(this.ClassType, Query.singleton(JvmTypeInfo.UNBOUNDED_WILDCARD));
                    }
                    return unboundedClassType;
                } else {
                    return parent.UnboundedClassType;
                }
            }
        }
        
        public JvmMethodInfo getBoxingMethod(JvmTypeInfo type) {
            ClassFileType ctype = null;
            boolean isBoolean;
            if (type.IsPrimitive) {
                isBoolean = false;
                switch (type.TypeKind) {
                case Boolean:
                    ctype = (ClassFileType)getType("java/lang/Boolean");
                    isBoolean = true;
                    break;
                case Byte:
                    ctype = (ClassFileType)getType("java/lang/Byte");
                    break;
                case Char:
                    ctype = (ClassFileType)getType("java/lang/Character");
                    break;
                case Short:
                    ctype = (ClassFileType)getType("java/lang/Short");
                    break;
                case Int:
                    ctype = (ClassFileType)getType("java/lang/Integer");
                    break;
                case Long:
                    ctype = (ClassFileType)getType("java/lang/Long");
                    break;
                case Float:
                    ctype = (ClassFileType)getType("java/lang/Float");
                    break;
                case Double:
                    ctype = (ClassFileType)getType("java/lang/Double");
                    break;
                }
            } else if (type instanceof ClassFileType) {
                isBoolean = type.FullName.equals("java/lang/Boolean");
                if (type.NumericTypeKind == NumericTypeKind.None && !isBoolean) {
                    return null;
                }
                ctype = (ClassFileType)type;
            } else {
                return null;
            }
            if (ctype.boxingMethod == null) {
                if (isBoolean) {
                    ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.BOOLEAN));
                } else {
                    switch (ctype.NumericTypeKind) {
                    case Byte:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.BYTE));
                        break;
                    case Char:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.CHAR));
                        break;
                    case Short:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.SHORT));
                        break;
                    case Int:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.INT));
                        break;
                    case Long:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.LONG));
                        break;
                    case Float:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.FLOAT));
                        break;
                    case Double:
                        ctype.boxingMethod = ctype.getMethod("valueOf", Collections.singletonList(JvmTypeInfo.DOUBLE));
                        break;
                    }
                }
            }
            return ctype.boxingMethod;
        }

        public JvmMethodInfo getUnboxingMethod(JvmTypeInfo type) {
            ClassFileType ctype = null;
            boolean isBoolean;
            if (type.IsPrimitive) {
                isBoolean = false;
                switch (type.TypeKind) {
                case Boolean:
                    ctype = (ClassFileType)getType("java/lang/Boolean");
                    isBoolean = true;
                    break;
                case Byte:
                    ctype = (ClassFileType)getType("java/lang/Byte");
                    break;
                case Char:
                    ctype = (ClassFileType)getType("java/lang/Character");
                    break;
                case Short:
                    ctype = (ClassFileType)getType("java/lang/Short");
                    break;
                case Int:
                    ctype = (ClassFileType)getType("java/lang/Integer");
                    break;
                case Long:
                    ctype = (ClassFileType)getType("java/lang/Long");
                    break;
                case Float:
                    ctype = (ClassFileType)getType("java/lang/Float");
                    break;
                case Double:
                    ctype = (ClassFileType)getType("java/lang/Double");
                    break;
                }
            } else if (type instanceof ClassFileType) {
                isBoolean = type.FullName.equals("java/lang/Boolean");
                if (type.NumericTypeKind == NumericTypeKind.None && !isBoolean) {
                    return null;
                }
                ctype = (ClassFileType)type;
            } else {
                return null;
            }
            if (ctype.unboxingMethod == null) {
                if (isBoolean) {
                    ctype.unboxingMethod = ctype.getMethod("booleanValue", Query.empty<JvmTypeInfo>());
                } else {
                    switch (ctype.NumericTypeKind) {
                    case Byte:
                        ctype.unboxingMethod = ctype.getMethod("byteValue", Query.empty<JvmTypeInfo>());
                        break;
                    case Char:
                        ctype.unboxingMethod = ctype.getMethod("charValue", Query.empty<JvmTypeInfo>());
                        break;
                    case Short:
                        ctype.unboxingMethod = ctype.getMethod("shortValue", Query.empty<JvmTypeInfo>());
                        break;
                    case Int:
                        ctype.unboxingMethod = ctype.getMethod("intValue", Query.empty<JvmTypeInfo>());
                        break;
                    case Long:
                        ctype.unboxingMethod = ctype.getMethod("longValue", Query.empty<JvmTypeInfo>());
                        break;
                    case Float:
                        ctype.unboxingMethod = ctype.getMethod("floatValue", Query.empty<JvmTypeInfo>());
                        break;
                    case Double:
                        ctype.unboxingMethod = ctype.getMethod("doubleValue", Query.empty<JvmTypeInfo>());
                        break;
                    }
                }
            }
            return ctype.unboxingMethod;
        }
        
        private void initializeBootClasses() {
            var jreLibPath = PathHelper.combine(System.getProperty("java.home"), "lib");
            var rtJarFile = new File(PathHelper.combine(jreLibPath, "rt.jar"));
            if (!rtJarFile.exists()) {
                // Probably Mac OS
                jreLibPath = PathHelper.combine(PathHelper.getDirectoryName(System.getProperty("java.home")), "Classes");
                rtJarFile = new File(PathHelper.combine(jreLibPath, "classes.jar"));
            }

			var zipFile = new ZipFile(rtJarFile);
			exploreJarFile(zipFile);
        }
        
        private void explorePath(String path) {
            var file = new File(path);
            if (file.exists()) {
                if (file.isDirectory()) {
                    foreach (var root in file.list()) {
                        var subFile = new File(file, root);
                        if (subFile.isDirectory()) {
                            exploreDirectory("", subFile);
                        } else {
                            var name = subFile.getName();
                            if (name.endsWith(".class")) {
                                var className = name.substring(0, name.length() - 6);
                                classFiles[className] = subFile;
                                allClassNames.add(className);
                            }
                        }
                    }
                } else {
                    exploreJarFile(new ZipFile(file));
                }
            } else {
                throw new IllegalStateException(path + " not found");
            }
        }

        private void exploreDirectory(String root, File directory) {
            foreach (var content in directory.list()) {
                var file = new File(directory, content);
                if (file.isDirectory()) {
                    exploreDirectory(root + directory.getName() + '/', file);
                } else {
                    var name = file.getName();
                    if (name.endsWith(".class")) {
                        var className = root + directory.getName() + '/' + name.substring(0, name.length() - 6);
                        if (!classFiles.containsKey(className)) {
                            classFiles[className] = file;
                            allClassNames.add(className);
                        }
                    }
                }
            }
        }
        
        private void exploreJarFile(ZipFile jarFile) {
			var e = jarFile.entries();
			while (e.hasMoreElements()) {
				var entry = e.nextElement();
				var name = entry.getName();
				if (name.endsWith(".class")) {
					var className = name.substring(0, name.length() - 6);
					if (!jarClasses.containsKey(className)) {
						jarClasses[className] = jarFile;
						allClassNames.add(className);
					}
				}
			}
        }
    }
}
