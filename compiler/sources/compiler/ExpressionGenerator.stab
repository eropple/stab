/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.lang;
using java.util;
using stab.bytecode;
using stab.query;
using stab.syntaxtree;

package stab.compiler {

	class TargetLabels {
		JvmLabelMarker ifTrue;
		JvmLabelMarker ifFalse;
		
		TargetLabels(JvmLabelMarker ifTrue, JvmLabelMarker ifFalse) {
			this.ifTrue = ifTrue;
			this.ifFalse = ifFalse;
		}
	}

	class ExpressionGenerator : ExpressionHandler<TargetLabels, Void> {
		private BytecodeGenerator bytecodeGenerator;
		private CompilerContext context;
	
		ExpressionGenerator(BytecodeGenerator bytecodeGenerator, CompilerContext context)
			: super(true) {
			this.bytecodeGenerator = bytecodeGenerator;
			this.context = context;
		}
		
		public override Void handleExpression(ExpressionNode expression, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			if (expression.Line != 0 && expression.Line != context.MethodGenerationContext.PreviousLineNumber) {
                var label = generator.defineLabel();
                generator.markLabel(label);
                generator.lineNumber(expression.Line, label);
                context.MethodGenerationContext.PreviousLineNumber = expression.Line;
            }            
			var info = expression.getUserData(typeof(ExpressionInfo));
			if (info == null) {
				generator.emit(JvmOpcode.Aconst_Null);
				return null;
			}
			if (!info.IsConstant) {
				return super.handleExpression(expression, labels, nested);
			}
			var value = info.Value;
			if (info.Type.IsBoolean) {
				if (((Boolean)value).booleanValue()) {
					generator.emit(JvmOpcode.Iconst_1);
				} else {
					generator.emit(JvmOpcode.Iconst_0);
				}
				emitBoxing(expression);
				if (labels != null) {
					generator.emit((info.Negate) ? JvmOpcode.Ifeq : JvmOpcode.Ifne, labels.ifFalse);
				}
			} else {
				switch (info.Type.NumericTypeKind) {
				case Char:
				case Byte:
				case Short:
				case Int:
					if (value instanceof Integer) {
						BytecodeHelper.emitIntConstant(generator, ((Integer)value).intValue());
					} else if (value instanceof Character) {
						BytecodeHelper.emitIntConstant(generator, ((Character)value).charValue());
					} else if (value instanceof Byte) {
						BytecodeHelper.emitIntConstant(generator, ((Byte)value).byteValue());
					} else if (value instanceof Short) {
						BytecodeHelper.emitIntConstant(generator, ((Short)value).shortValue());
					}
					break;

				case Long:
					long l = 0;
					if (value instanceof Long) {
						l = ((Long)value).longValue();
					} else if (value instanceof Integer) {
						l = ((Integer)value).intValue();
					} else if (value instanceof Character) {
						l = ((Character)value).charValue();
					} else if (value instanceof Byte) {
						l = ((Byte)value).byteValue();
					} else if (value instanceof Short) {
						l = ((Short)value).shortValue();
					}
					if (l == 0) {
						generator.emit(JvmOpcode.Lconst_0);
					} else if (l == 1) {
						generator.emit(JvmOpcode.Lconst_1);
					} else {
						generator.emit(JvmOpcode.Ldc, Long.valueOf(l));
					}
					break;

				case Float:
					float f = 0;
					if (value instanceof Float) {
						f = ((Float)value).floatValue();
					} else if (value instanceof Long) {
						f = ((Long)value).longValue();
					} else if (value instanceof Integer) {
						f = ((Integer)value).intValue();
					} else if (value instanceof Character) {
						f = ((Character)value).charValue();
					} else if (value instanceof Byte) {
						f = ((Byte)value).byteValue();
					} else if (value instanceof Short) {
						f = ((Short)value).shortValue();
					}
					if (f == 0f) {
						generator.emit(JvmOpcode.Fconst_0);
					} else if (f == 1f) {
						generator.emit(JvmOpcode.Fconst_1);
					} else if (f == 2f) {
						generator.emit(JvmOpcode.Fconst_2);
					} else {
						generator.emit(JvmOpcode.Ldc, Float.valueOf(f));
					}
					break;

				case Double:
					double d = 0;
					if (value instanceof Double) {
						d = ((Double)value).doubleValue();
					} else if (value instanceof Float) {
						d = ((Float)value).floatValue();
					} else if (value instanceof Long) {
						d = ((Long)value).longValue();
					} else if (value instanceof Integer) {
						d = ((Integer)value).intValue();
					} else if (value instanceof Character) {
						d = ((Character)value).charValue();
					} else if (value instanceof Byte) {
						d = ((Byte)value).byteValue();
					} else if (value instanceof Short) {
						d = ((Short)value).shortValue();
					}
					if (d == 0d) {
						generator.emit(JvmOpcode.Dconst_0);
					} else if (d == 1d) {
						generator.emit(JvmOpcode.Dconst_1);
					} else {
						generator.emit(JvmOpcode.Ldc, Double.valueOf(d));
					}
					break;

				default:
					generator.emit(JvmOpcode.Ldc, value);
					break;
				}
				emitBoxing(expression);
			}
			return null;
		}

		protected override Void handleAnonymousObjectCreation(AnonymousObjectCreationExpressionNode anonymousObject,
				TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var type = anonymousObject.getUserData(typeof(ExpressionInfo)).Type;
			generator.emit(JvmOpcode.New, type);
			if (nested) {
				generator.emit(JvmOpcode.Dup);
			}
			foreach (var decl in anonymousObject.MemberDeclarators) {
				handleExpression(decl.Value, null, true);
			}
			var constructor = type.Methods.where(p => p.Name.equals("<init>")).first();
			generator.emit(JvmOpcode.Invokespecial, constructor);
			return null;
		}
		
		protected override Void handleArrayCreation(ArrayCreationExpressionNode arrayCreation, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			foreach (var e in arrayCreation.DimensionExpressions) {
				handleExpression(e, null, true);
			}
			var type = arrayCreation.getUserData(typeof(ExpressionInfo)).Type;
			var initializer = arrayCreation.Initializer;
			int dimensions = arrayCreation.DimensionExpressions.size();
			if (dimensions <= 1) {
				if (dimensions == 0) {
					BytecodeHelper.emitIntConstant(generator, initializer.Values.size());
				}
			}
			bytecodeGenerator.emitArray(dimensions, type, (initializer == null) ? null : initializer.Values.iterator()); 
			return null;
		}
		
		protected override Void handleArrayInitializer(ArrayInitializerExpressionNode arrayInitializer, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var type = arrayInitializer.getUserData(typeof(ExpressionInfo)).Type;
			BytecodeHelper.emitIntConstant(generator, arrayInitializer.Values.size());
			bytecodeGenerator.emitArray(0, type, arrayInitializer.Values.iterator()); 
			return null;
		}
		
		protected override Void handleAssign(AssignExpressionNode assign, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			new AssignExpressionGenerator(context, this).handleExpression(assign.Left, assign, nested);
			emitBoxing(assign);
			emitTest(assign.getUserData(typeof(ExpressionInfo)), labels);
			return null;
		}
		
		protected override Void handleBinary(BinaryExpressionNode binary, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var info = binary.getUserData(typeof(ExpressionInfo));
			var left = binary.LeftOperand;
			var right = binary.RightOperand;
			var li = left.getUserData(typeof(ExpressionInfo));
			var ri = right.getUserData(typeof(ExpressionInfo));
			var leftIsZero = li != null && CompilerHelper.isZero(li);
			var rightIsZero = ri != null && CompilerHelper.isZero(ri);

			switch (binary.Operator) {
			case Add:
				if (info.Type.FullName.equals("java/lang/String")) {
					var isBuildingString = context.MethodGenerationContext.IsBuildingString;
					var stringBuilderType = context.TypeSystem.getType("java/lang/StringBuilder");
					var stringType = context.TypeSystem.getType("java/lang/String");
					if (!isBuildingString) {
						generator.emit(JvmOpcode.New, stringBuilderType);
						generator.emit(JvmOpcode.Dup);
						generator.emit(JvmOpcode.Invokespecial, stringBuilderType.getMethod("<init>", Query.empty<JvmTypeInfo>()));
					}
					var isStringAdd = left.ExpressionKind == ExpressionKind.Binary && li != null && li.Type == stringType;
					context.MethodGenerationContext.IsBuildingString = isStringAdd;
					handleExpression(left, null, true);
					if (!isStringAdd) {
						BytecodeGenerator.emitStringBuilderAppend(context, stringBuilderType, li);
					}
					isStringAdd = right.ExpressionKind == ExpressionKind.Binary && ri != null && ri.Type == stringType;
					context.MethodGenerationContext.IsBuildingString = isStringAdd;
					handleExpression(right, null, true);
					if (!isStringAdd) {
						BytecodeGenerator.emitStringBuilderAppend(context, stringBuilderType, ri);
					}
					if (!isBuildingString) {
						generator.emit(JvmOpcode.Invokevirtual, context.TypeSystem.ObjectType.getMethod("toString", Query.empty<JvmTypeInfo>()));
					}
					context.MethodGenerationContext.IsBuildingString = isBuildingString;
				} else {
					emitOperands(left, false, right, false);
					switch (info.Type.NumericTypeKind) {
					case Byte:
					case Char:
					case Short:
					case Int:
						generator.emit(JvmOpcode.Iadd);
						break;
					case Long:
						generator.emit(JvmOpcode.Ladd);
						break;
					case Float:
						generator.emit(JvmOpcode.Fadd);
						break;
					case Double:
						generator.emit(JvmOpcode.Dadd);
						break;
					default:
						if (BytecodeHelper.isDelegateType(info.Type)) {
							var delegateType = context.TypeSystem.getType("stab/lang/Delegate");
							var argTypes = new ArrayList<JvmTypeInfo> { delegateType, delegateType };
							generator.emit(JvmOpcode.Invokestatic, delegateType.getMethod("combine", argTypes));
							generator.emit(JvmOpcode.Checkcast, info.Type);
						} else {
							throw new Exception("Internal error");
						}
						break;
					}
					emitBoxing(binary);
				}
				break;
			
			case Subtract:
				emitOperands(left, false, right, false);
				switch (info.getType().NumericTypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int:
					generator.emit(JvmOpcode.Isub);
					break;
				case Long:
					generator.emit(JvmOpcode.Lsub);
					break;
				case Float:
					generator.emit(JvmOpcode.Fsub);
					break;
				case Double:
					generator.emit(JvmOpcode.Dsub);
					break;
				default:
					if (BytecodeHelper.isDelegateType(info.Type)) {
						var delegateType = context.getTypeSystem().getType("stab/lang/Delegate");
						var argTypes = new ArrayList<JvmTypeInfo> { delegateType, delegateType };
						generator.emit(JvmOpcode.Invokestatic, delegateType.getMethod("remove", argTypes));
						generator.emit(JvmOpcode.Checkcast, info.Type);
					} else {
						throw new RuntimeException("Internal error");
					}
					break;
				}
				emitBoxing(binary);
				break;

			case Multiply:
				emitOperands(left, false, right, false);
				JvmOpcode opcode;
				switch (info.Type.NumericTypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int:
					opcode = JvmOpcode.Imul;
					break;
				case Long:
					opcode = JvmOpcode.Lmul;
					break;
				case Float:
					opcode = JvmOpcode.Fmul;
					break;
				case Double:
					opcode = JvmOpcode.Dmul;
					break;
				default:
					throw new Exception("Internal error");
				}
				generator.emit(opcode);
				emitBoxing(binary);
				break;
				
			case Divide:
				emitOperands(left, false, right, false);
				switch (info.Type.NumericTypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int:
					opcode = JvmOpcode.Idiv;
					break;
				case Long:
					opcode = JvmOpcode.Ldiv;
					break;
				case Float:
					opcode = JvmOpcode.Fdiv;
					break;
				case Double:
					opcode = JvmOpcode.Ddiv;
					break;
				default:
					throw new Exception("Internal error");
				}
				generator.emit(opcode);
				emitBoxing(binary);
				break;
				
			case Modulo:
				emitOperands(left, false, right, false);
				switch (info.Type.NumericTypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int:
					opcode = JvmOpcode.Irem;
					break;
				case Long:
					opcode = JvmOpcode.Lrem;
					break;
				case Float:
					opcode = JvmOpcode.Frem;
					break;
				case Double:
					opcode = JvmOpcode.Drem;
					break;
				default:
					throw new RuntimeException("Internal error");
				}
				generator.emit(opcode);
				emitBoxing(binary);
				break;

			case And:
				emitOperands(left, false, right, false);
				if (info.Type.IsBoolean) {
					opcode = JvmOpcode.Iand;
				} else {
					switch (info.Type.NumericTypeKind) {
					case Byte:
					case Char:
					case Short:
					case Int:
						opcode = JvmOpcode.Iand;
						break;
					case Long:
						opcode = JvmOpcode.Land;
						break;
					default:
						throw new Exception("Internal error");
					}
				}
				generator.emit(opcode);
				emitBoxing(binary);
				break;
				
			case Or:
				emitOperands(left, false, right, false);
				if (info.Type.IsBoolean) {
					opcode = JvmOpcode.Ior;
				} else {
					switch (info.Type.NumericTypeKind) {
					case Byte:
					case Char:
					case Short:
					case Int:
						opcode = JvmOpcode.Ior;
						break;
					case Long:
						opcode = JvmOpcode.Lor;
						break;
					default:
						throw new Exception("Internal error");
					}
				}
				generator.emit(opcode);
				emitBoxing(binary);
				break;
				
			case Xor:
				emitOperands(left, false, right, false);
				if (info.Type.IsBoolean) {
					opcode = JvmOpcode.Ixor;
				} else {
					switch (info.Type.NumericTypeKind) {
					case Byte:
					case Char:
					case Short:
					case Int:
						opcode = JvmOpcode.Ixor;
						break;
					case Long:
						opcode = JvmOpcode.Lxor;
						break;
					default:
						throw new Exception("Internal error");
					}
				}
				generator.emit(opcode);
				emitBoxing(binary);
				break;
				
			case LessThan:
				if (labels != null) {
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifle, JvmOpcode.Ifge, JvmOpcode.If_icmpge, labels.ifFalse);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifgt, JvmOpcode.Iflt, JvmOpcode.If_icmplt, labels.ifFalse);
					}
				} else {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifle, JvmOpcode.Ifge, JvmOpcode.If_icmpge, elseLabel);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifgt, JvmOpcode.Iflt, JvmOpcode.If_icmplt, elseLabel);
					}
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
				
			case LessThanOrEqual:
				if (labels != null) {
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Iflt, JvmOpcode.Ifgt, JvmOpcode.If_icmpgt, labels.ifFalse);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifge, JvmOpcode.Ifle, JvmOpcode.If_icmple, labels.ifFalse);
					}
				} else {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Iflt, JvmOpcode.Ifgt, JvmOpcode.If_icmpgt, elseLabel);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifge, JvmOpcode.Ifle, JvmOpcode.If_icmple, elseLabel);
					}
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
				
			case GreaterThan:
				if (labels != null) {
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifge, JvmOpcode.Ifle, JvmOpcode.If_icmple, labels.ifFalse);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Iflt, JvmOpcode.Ifgt, JvmOpcode.If_icmpgt, labels.ifFalse);
					}
				} else {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifge, JvmOpcode.Ifle, JvmOpcode.If_icmple, elseLabel);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Iflt, JvmOpcode.Ifgt, JvmOpcode.If_icmpgt, elseLabel);
					}
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
				
			case GreaterThanOrEqual:
				if (labels != null) {
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifgt, JvmOpcode.Iflt, JvmOpcode.If_icmplt, labels.ifFalse);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifle, JvmOpcode.Ifge, JvmOpcode.If_icmpge, labels.ifFalse);
					}
				} else {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					if (info.Negate) {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifgt, JvmOpcode.Iflt, JvmOpcode.If_icmplt, elseLabel);
					} else {
						emitComparison(binary, leftIsZero, rightIsZero, JvmOpcode.Ifle, JvmOpcode.Ifge, JvmOpcode.If_icmpge, elseLabel);
					}
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
				
			case Equal:
				if (labels != null) {
					emitEquality(binary, leftIsZero, rightIsZero, labels.ifFalse, info.Negate);
				} else {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					emitEquality(binary, leftIsZero, rightIsZero, elseLabel, info.Negate);
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
				
			case NotEqual:
				if (labels != null) {
					emitEquality(binary, leftIsZero, rightIsZero, labels.ifFalse, !info.Negate);
				} else {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					emitEquality(binary, leftIsZero, rightIsZero, elseLabel, !info.Negate);
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
			
			case LogicalAnd:
				if (labels != null) {
					if (info.Negate) {
						var then2Label = generator.defineLabel();
						handleExpression(left, new TargetLabels(then2Label, labels.ifFalse), true);
						generator.markLabel(then2Label);
						handleExpression(right, labels, true);
					} else {
						var then2Label = generator.defineLabel();
						handleExpression(left, new TargetLabels(then2Label, labels.ifTrue), true);
						ri.Negate = false;
						handleExpression(right, labels, true);
						generator.markLabel(then2Label);
					}
				} else {
					var thenLabel = generator.defineLabel();
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					handleExpression(left, new TargetLabels(thenLabel, elseLabel), true);
					handleExpression(right, new TargetLabels(thenLabel, elseLabel), true);
					generator.markLabel(thenLabel);
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
				
			case LogicalOr: {
				if (labels != null) {
					if (info.Negate) {
						var then2Label = generator.defineLabel();
						li.Negate = false;
						handleExpression(left, new TargetLabels(then2Label, labels.ifTrue), true);
						generator.markLabel(then2Label);
						handleExpression(right, labels, true);
					} else {
						var then2Label = generator.defineLabel();
						li.Negate = false;
						handleExpression(left, new TargetLabels(then2Label, labels.ifFalse), true);
						generator.markLabel(then2Label);
						ri.Negate = false;
						handleExpression(right, labels, true);
					}
				} else {
					var thenLabel = generator.defineLabel();
					var then2Label = generator.defineLabel();
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					li.Negate = false;
					handleExpression(left, new TargetLabels(then2Label, thenLabel), true);
					generator.markLabel(then2Label);
					handleExpression(right, new TargetLabels(thenLabel, elseLabel), true);
					generator.markLabel(thenLabel);
					generator.emit(JvmOpcode.Iconst_1);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.markLabel(endLabel);
				}
				emitBoxing(binary);
				break;
			}
			case LeftShift:
				handleExpression(left, null, true);
				handleExpression(right, null, true);
				if (info.Type == JvmTypeInfo.INT) {
					generator.emit(JvmOpcode.Ishl);
				} else if (info.Type == JvmTypeInfo.LONG) {
					generator.emit(JvmOpcode.Lshl);
				} else {
					throw new Exception("Internal error");
				}
				emitBoxing(binary);
				break;
				
			case RightShift:
				handleExpression(left, null, true);
				handleExpression(right, null, true);
				if (info.Type == JvmTypeInfo.INT) {
					generator.emit(JvmOpcode.Ishr);
				} else if (info.Type == JvmTypeInfo.LONG) {
					generator.emit(JvmOpcode.Lshr);
				} else {
					throw new Exception("Internal error");
				}
				emitBoxing(binary);
				break;
				
			case UnsignedRightShift:
				handleExpression(left, null, true);
				handleExpression(right, null, true);
				if (info.Type == JvmTypeInfo.INT) {
					generator.emit(JvmOpcode.Iushr);
				} else if (info.Type == JvmTypeInfo.LONG) {
					generator.emit(JvmOpcode.Lushr);
				} else {
					throw new Exception("Internal error");
				}
				emitBoxing(binary);
				break;
				
			case Instanceof:
				handleExpression(left, null, true);
				generator.emit(JvmOpcode.Instanceof, ri.Type);
				emitBoxing(binary);
				if (labels != null) {
					generator.emit(JvmOpcode.Ifeq, labels.ifFalse);
				}
				break;
				
			case As: {
				handleExpression(left, null, true);
				generator.emit(JvmOpcode.Dup);
				generator.emit(JvmOpcode.Instanceof, ri.Type);
				var elseLabel = generator.defineLabel();
				var endLabel = generator.defineLabel();
				generator.emit(JvmOpcode.Ifne, elseLabel);
				generator.emit(JvmOpcode.Pop);
				generator.emit(JvmOpcode.Aconst_Null);
				generator.emit(JvmOpcode.Goto, endLabel);
				generator.markLabel(elseLabel);
				generator.emit(JvmOpcode.Checkcast, ri.Type);
				generator.markLabel(endLabel);
				emitBoxing(binary);
				break;
			}				
			case NullCoalescing: {
				handleExpression(left, null, true);
				generator.emit(JvmOpcode.Dup);
				var endLabel = generator.defineLabel();
				generator.emit(JvmOpcode.Ifnonnull, endLabel);
				generator.emit(JvmOpcode.Pop);
				handleExpression(right, null, true);
				generator.markLabel(endLabel);
				emitBoxing(binary);
				break;
			}
			default:
				throw new Exception("Internal error");
			}
			return null;
		}

		protected override Void handleCast(CastExpressionNode cast, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			handleExpression(cast.Expression, null, nested);
			var einfo = cast.Expression.getUserData(typeof(ExpressionInfo));
			var info = cast.getUserData(typeof(ExpressionInfo));
			var type = info.Type;
			if (einfo != null && einfo.Type != type) {
				if (einfo.Type.IsNumeric) {
					BytecodeHelper.emitNumericConversion(generator, einfo.Type, type);
				} else if (info.OriginalType != null) {
					generator.emit(JvmOpcode.Checkcast, info.OriginalType);
				} else if (info.Type.OriginalTypeDefinition != einfo.Type.OriginalTypeDefinition) {
					if (!info.Type.IsGenericParameter || info.Type.GenericParameterBounds.any()) {
						generator.emit(JvmOpcode.Checkcast, type);
					}
				}
			}
			emitBoxing(cast);
			emitTest(info, labels);
			return null;
		}
		
		protected override Void handleConditional(ConditionalExpressionNode conditional, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var thenLabel = generator.defineLabel();
			var elseLabel = generator.defineLabel();
			var endLabel = generator.defineLabel();
			var info = conditional.getUserData(typeof(ExpressionInfo));
			handleExpression(conditional.Condition, new TargetLabels(thenLabel, elseLabel), true);
			generator.markLabel(thenLabel);
			handleExpression(conditional.IfTrue, null, true);
			BytecodeGenerator.emitConversion(context, info.Type, conditional.IfTrue);
			generator.emit(JvmOpcode.Goto, endLabel);
			generator.markLabel(elseLabel);
			handleExpression(conditional.IfFalse, null, true);
			BytecodeGenerator.emitConversion(context, info.Type, conditional.IfFalse);
			generator.markLabel(endLabel);
			emitBoxing(conditional);
			emitTest(info, labels);
			return null;
		}
		
		protected override Void handleElementAccess(ElementAccessExpressionNode elementAccess, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var target = elementAccess.TargetObject;
			var tinfo = target.getUserData(typeof(ExpressionInfo));
			var ttype = tinfo.Type;
			if (!ttype.IsArray) {
				var method = elementAccess.getUserData(typeof(ExpressionInfo)).Member.GetAccessor;
				if (!method.IsStatic) {
					handleExpression(target, null, true);
				}
				var it = method.Parameters.iterator();
				foreach (var e in elementAccess.Indexes) {
					handleExpression(e, null, true);
					var p = it.next();
					BytecodeGenerator.emitConversion(context, p.Type, e);
				}
				BytecodeGenerator.emitIndexerAccess(context, method);
				BytecodeGenerator.emitGenericCast(context, method.ReturnType, method.OriginalMethodDefinition.ReturnType);
			} else {
				handleExpression(target, null, true);
				var index = elementAccess.Indexes[0];
				handleExpression(index, null, true);
				BytecodeHelper.emitNumericConversion(generator, index.getUserData(typeof(ExpressionInfo)).Type, JvmTypeInfo.INT);
				generator.emit(BytecodeHelper.getAloadOpcode(ttype.ElementType));
			}
			emitBoxing(elementAccess);
			emitTest(elementAccess.getUserData(typeof(ExpressionInfo)), labels);
			return null;
		}
		
		protected override Void handleInvocation(InvocationExpressionNode invocation, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var info = invocation.getUserData(typeof(ExpressionInfo));
			var method = info.Method;
			if (method.IsExcludedFromCompilation || CompilerHelper.shouldIgnoreCalls(context, method)) {
				return null;
			}
			foreach (var ann in BytecodeHelper.getAnnotations(context.AnnotatedTypeSystem, method)) {
				if (BytecodeHelper.isConditional(ann)) {
					var generate = false;
					foreach (var elt in ann.getArgument("symbols").Elements) {
						if (context.Symbols.contains(elt.Value)) {
							generate = true;
							break;
						}
					}
					if (!generate) {
						return null;
					}
					break;
				}
			}
			if (!method.IsStatic) {
				if (BytecodeHelper.isDelegateType(method.DeclaringType) && method.Name.equals("invoke")) {
					handleExpression(invocation.TargetObject, null, true);
				} else if (invocation.TargetObject.ExpressionKind == ExpressionKind.MemberAccess) {
					var targetTarget = ((MemberAccessExpressionNode)invocation.TargetObject).TargetObject;
					handleExpression(targetTarget, null, true);
					BytecodeGenerator.emitGenericCast(context, method.DeclaringType, targetTarget.getUserData(typeof(ExpressionInfo)).Type);
				} else { // SimpleName
					BytecodeGenerator.emitThisAccess(context, generator);
				}
			}
			int nParams = method.Parameters.count();
			int len = (method.IsVarargs) ? nParams - 1 : nParams;
			var arguments = invocation.Arguments;
			if (info.IsExtension) {
				var target = (MemberAccessExpressionNode)invocation.TargetObject;
				arguments = new ArrayList<ExpressionNode> { target.TargetObject };
				arguments.addAll(invocation.Arguments);
			}
			emitArguments(arguments, method.Parameters, len, arguments.size() - len, method.IsVarargs);
			emitMethodAccess(method, invocation.TargetObject.getUserData(typeof(ExpressionInfo)).IsSuperCall);
			if (nested) {
				var gm = method.OriginalMethodDefinition;
				if (method != gm) {
					BytecodeGenerator.emitGenericCast(context, method.ReturnType, gm.ReturnType);
				}
			} else {
				switch (method.ReturnType.TypeKind) {
				case Long:
				case Double:
					generator.emit(JvmOpcode.Pop2);
					break;
				case Void:
					break;
				default:
					generator.emit(JvmOpcode.Pop);
					break;
				}
			}
			emitBoxing(invocation);
			emitTest(info, labels);
			return null;
		}
		
		protected override Void handleLambda(LambdaExpressionNode lambda, TargetLabels labels, boolean nested) {
			var targetType = lambda.getUserData(typeof(ExpressionInfo)).Type;
			var typeBuilder = context.MethodGenerationContext.LambdaScope;
			
			var methodBuilder = lambda.getUserData(typeof(JvmMethodBuilder));
			context.MethodGenerationContext.enterLambda(methodBuilder);
			var gen = methodBuilder.CodeGenerator;
			var oldIsLambdaScopeUsed = context.MethodGenerationContext.IsLambdaScopeUsed;
			context.MethodGenerationContext.IsLambdaScopeUsed = false;
			gen.beginScope();
			bytecodeGenerator.handleStatement(lambda.Body, null);
			gen.endScope();
			var isLambdaScopeUsed = context.MethodGenerationContext.IsLambdaScopeUsed;
			if (!isLambdaScopeUsed) {
				gen.removeThis();
				methodBuilder.setStatic(true);
			}
			context.MethodGenerationContext.leaveLambda();
			context.MethodGenerationContext.IsLambdaScopeUsed = oldIsLambdaScopeUsed;
			if (isLambdaScopeUsed) {
				BytecodeGenerator.getLambdaScope(context, context.MethodGenerationContext.CurrentMethod);
			}
			
			ExpressionNode arg = null;
			if (isLambdaScopeUsed) {
				arg = new SimpleNameExpressionNode();
				var ainfo = new ExpressionInfo(context.MethodGenerationContext.LambdaScope);
				if (context.MethodGenerationContext.IsInLambda) {
					ainfo.Member = new LocalInfo("this", typeBuilder, context.MethodGenerationContext.CurrentMethod, false);
				} else {
					ainfo.Member = new LocalInfo("lambda$scope", typeBuilder, context.MethodGenerationContext.CurrentMethod, false);
				}
				arg.addUserData(ainfo);
			}
			if (BytecodeHelper.isDelegateType(targetType)) {
				emitDelegateCreation(targetType, methodBuilder, arg, nested);
			} else {
				emitInterfaceCreation(targetType, methodBuilder, arg, nested);
			}
			return null;
		}
		
		protected override Void handleMemberAccess(MemberAccessExpressionNode memberAccess, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var info = memberAccess.getUserData(typeof(ExpressionInfo));
			if (info.Method != null) {
				emitDelegateCreation(info.Type, info.Method, memberAccess, nested);
				return null;
			}
			var member = info.Member;
			if (member == null) {
				handleExpression(memberAccess.TargetObject, null, true);
				return null;
			}
			switch (member.MemberKind) {
			case Field: {
				var field = member.Field;
				if (!field.IsStatic) {
					handleExpression(memberAccess.TargetObject, null, true);
				}
				BytecodeGenerator.emitFieldAccess(context, field);
				BytecodeGenerator.emitGenericCast(context, field.Type, field.DeclaringType.OriginalTypeDefinition.getField(field.Name).Type);
				emitBoxing(memberAccess);
				emitTest(info, labels);
				return null;
			}
			case Property: {
				var method = member.GetAccessor;
				if (!method.IsStatic) {
					handleExpression(memberAccess.TargetObject, null, true);
				}
				BytecodeGenerator.emitPropertyAccess(context, method);
				BytecodeGenerator.emitGenericCast(context, method.ReturnType, method.OriginalMethodDefinition.ReturnType);
				emitBoxing(memberAccess);
				emitTest(info, labels);
				return null;
			}
			default:
				throw new IllegalStateException("Internal error: unhandled member kind: " + member.MemberKind);
			}
		}

		protected override Void handleObjectCreation(ObjectCreationExpressionNode objectCreation, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var info = objectCreation.getUserData(typeof(ExpressionInfo));
			var method = info.Method;
			if (BytecodeHelper.isDelegateType(info.Type)) {
				emitDelegateCreation(info.Type, method, objectCreation.Arguments[0], nested);
				return null;
			}
			if (BytecodeGenerator.requireAccessor(context, method.DeclaringType, method.IsPublic, method.IsProtected, method.IsPrivate)) {
				var accessor = context.PrivateAccessors[method];
				if (accessor == null) {
					var outerClass = (JvmTypeBuilder)context.CurrentType;
					while ((outerClass = (JvmTypeBuilder)outerClass.DeclaringType) != null) {
						if (method.DeclaringType.isAssignableFrom(outerClass)) {
							break;
						}
					}
					int n = outerClass.Methods.count(p => p.Name.startsWith("accessor$"));
					var methodBuilder = outerClass.defineMethod("accessor$" + n);
					methodBuilder.setReturnType(method.DeclaringType);
					methodBuilder.setStatic(true);
					methodBuilder.setSynthetic(true);
					methodBuilder.setVarargs(method.IsVarargs);
					foreach (var p in method.Parameters) {
						var pb = methodBuilder.addParameter(p.Type);
						pb.setName(p.Name);
					}
					foreach (var t in method.Exceptions) {
						methodBuilder.addException(t);
					}
					var gen = methodBuilder.CodeGenerator;
					gen.beginScope();
					gen.emit(JvmOpcode.New, method.DeclaringType);
					gen.emit(JvmOpcode.Dup);
					foreach (var p in method.Parameters) {
						gen.emit(BytecodeHelper.getLoadOpcode(p.Type), gen.getLocal(p.Name));
					}
					gen.emit(JvmOpcode.Invokespecial, method);
					gen.emit(JvmOpcode.Areturn);
					gen.endScope();
					accessor = methodBuilder;
				}
				method = accessor;
			}
			if (method != info.Method) {
				int nParams = method.Parameters.count();
				int len = (method.IsVarargs) ?  nParams - 1 : nParams;
				emitArguments(objectCreation.Arguments, method.Parameters, len, objectCreation.Arguments.size() - len, method.IsVarargs);
				generator.emit(JvmOpcode.Invokestatic, method);
				if (!nested) {
					generator.emit(JvmOpcode.Pop);
				}
			} else {
				generator.emit(JvmOpcode.New, method.DeclaringType);
				if (nested) {
					generator.emit(JvmOpcode.Dup);
				}
				// TODO: move to emitArguments
				int nParams = method.Parameters.count();
				int len = (method.IsVarargs) ?  nParams - 1 : nParams;
				emitArguments(objectCreation.Arguments, method.Parameters, len, objectCreation.Arguments.size() - len, method.IsVarargs);
				generator.emit(JvmOpcode.Invokespecial, method);
			}
			emitBoxing(objectCreation);
			var init = objectCreation.Initializer;
			if (init != null) {
				if (init.ExpressionKind == ExpressionKind.ObjectInitializer) {
					var initializer = (ObjectInitializerExpressionNode)init;
					foreach (var mi in initializer.MemberInitializers) {
						MemberInfo prop = mi.getUserData(typeof(MemberInfo));
						if (!prop.IsStatic) {
							generator.emit(JvmOpcode.Dup);
						}
						handleExpression(mi.Value, null, true);
						emitBoxing(mi.Value);
						BytecodeGenerator.emitPropertyAccess(context, prop.SetAccessor);
					}
				} else {
					var initializer = (CollectionInitializerExpressionNode)init;
					var addMethod = initializer.getUserData(typeof(JvmMethodInfo));
					foreach (var args in initializer.Values) {
						generator.emit(JvmOpcode.Dup);
						foreach (var e in args) {
							handleExpression(e, null, true);
						}
						generator.emit(JvmOpcode.Invokevirtual, addMethod);
						if (addMethod.ReturnType != JvmTypeInfo.VOID) {
							generator.emit(JvmOpcode.Pop);
						}
					}
				}
			}
			emitTest(info, labels);
			return null;
		}
		
		protected override Void handleSimpleName(SimpleNameExpressionNode simpleName, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var info = simpleName.getUserData(typeof(ExpressionInfo));
			var member = info.Member;
			switch (member.MemberKind) {
			case Local: {
				var local = (LocalInfo)member;
				if (local.IsUsedFromLambda) {
					BytecodeGenerator.emitLoadLambdaScope(context, generator, local.Method);
					generator.emit(JvmOpcode.Getfield, BytecodeGenerator.getLambdaScopeField(context, local));
				} else {
					generator.emit(BytecodeHelper.getLoadOpcode(local.Type), generator.getLocal(local.Name));
				}
				emitBoxing(simpleName);
				emitTest(info, labels);
				return null;
			}
			case Field: {
				var field = member.Field;
				if (!field.IsStatic) {
					BytecodeGenerator.emitThisAccess(context, generator);
				}
				BytecodeGenerator.emitFieldAccess(context, field);
				BytecodeGenerator.emitGenericCast(context, field.Type, field.DeclaringType.OriginalTypeDefinition.getField(field.Name).Type);
				emitBoxing(simpleName);
				emitTest(info, labels);
				return null;
			}
			case Method: {
				if (info.Method != null) {
					var e = new ThisAccessExpressionNode();
					e.addUserData(new ExpressionInfo(context.CurrentType));
					emitDelegateCreation(info.Type, info.Method, e, nested);
				} else {
					BytecodeGenerator.emitThisAccess(context, generator);
					emitBoxing(simpleName);
				}
				return null;
			}
			case Property: {
				var method = member.GetAccessor;
				if (!method.IsStatic) {
					BytecodeGenerator.emitThisAccess(context, generator);
				}
				BytecodeGenerator.emitPropertyAccess(context, method);
				BytecodeGenerator.emitGenericCast(context, method.ReturnType, method.OriginalMethodDefinition.ReturnType);
				emitBoxing(simpleName);
				emitTest(info, labels);
				return null;
			}
			default:
				throw new Exception("Internal error: unhandled name kind: " + member.MemberKind);
			}
		}

		protected override Void handleSizeof(SizeofExpressionNode sizeofExpression, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			handleExpression(sizeofExpression.Expression, null, true);
			generator.emit(JvmOpcode.Arraylength);
			return null;
		}
		
		protected override Void handleSuperAccess(SuperAccessExpressionNode superAccess, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			BytecodeGenerator.emitThisAccess(context, generator);
			return null;
		}
		
		protected override Void handleThisAccess(ThisAccessExpressionNode thisAccess, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			BytecodeGenerator.emitThisAccess(context, generator);
			return null;
		}
		
		protected override Void handleTypeof(TypeofExpressionNode typeofExpression, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var type = typeofExpression.getUserData(typeof(JvmTypeInfo));
			BytecodeHelper.emitTypeof(generator, context.TypeSystem, type);
			return null;
		}
		
		protected override Void handleUnary(UnaryExpressionNode unary, TargetLabels labels, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var info = unary.getUserData(typeof(ExpressionInfo));
			var type = info.Type;
			switch (unary.Operator) {
			case Complement: {
				handleExpression(unary.Operand, null, true);
				JvmOpcode opcode;
				switch (type.NumericTypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int:
					generator.emit(JvmOpcode.Iconst_M1);
					opcode = JvmOpcode.Ixor;
					break;
					
				case Long:
					generator.emit(JvmOpcode.Ldc, new Long(-1));
					opcode = JvmOpcode.Lxor;
					break;
					
				default:
					throw new Exception("Internal error");
				}
				generator.emit(opcode);
				emitBoxing(unary);
				break;
			}
			case Minus: {
				handleExpression(unary.Operand, null, true);
				JvmOpcode opcode;
				switch (type.NumericTypeKind) {
				case Byte:
				case Char:
				case Int:
				case Short:
					opcode = JvmOpcode.Ineg;
					break;
				case Long:
					opcode = JvmOpcode.Lneg;
					break;
				case Double:
					opcode = JvmOpcode.Dneg;
					break;
				case Float:
					opcode = JvmOpcode.Fneg;
					break;
				default:
					throw new Exception("Internal error");
				}
				generator.emit(opcode);
				emitBoxing(unary);
				break;
			}
			case Not: {
				handleExpression(unary.Operand, null, true);
				if (labels == null) {
					var elseLabel = generator.defineLabel();
					var endLabel = generator.defineLabel();
					generator.emit(JvmOpcode.Ifeq, elseLabel);
					generator.emit(JvmOpcode.Iconst_0);
					generator.emit(JvmOpcode.Goto, endLabel);
					generator.markLabel(elseLabel);
					generator.emit(JvmOpcode.Iconst_1);
					generator.markLabel(endLabel);
				} else {
					if (info.Negate) {
						generator.emit(JvmOpcode.Ifne, labels.ifFalse);
					} else {
						generator.emit(JvmOpcode.Ifeq, labels.ifFalse);
					}
				}
				emitBoxing(unary);
				break;
			}
			case Plus: {
				handleExpression(unary.Operand, null, true);
				switch (type.NumericTypeKind) {
				case Byte:
				case Int:
				case Short:
				case Long:
				case Double:
				case Float:
					break;
				default:
					throw new Exception("Internal error");
				}
				emitBoxing(unary);
				break;
			}
			case PostIncrement:
			case PostDecrement:
			case PreDecrement:
			case PreIncrement: {
				new AssignExpressionGenerator(context, this).handleExpression(unary.Operand, unary, nested);
				emitBoxing(unary);
				break;
			}
			default:
				throw new RuntimeException("Internal error: unhandled unary operator " + unary.Operator);
			}
			return null;
		}
		
		private void emitTest(ExpressionInfo info, TargetLabels labels) {
			if (labels != null) {
				var generator = context.MethodGenerationContext.Generator;
				generator.emit((info.Negate) ? JvmOpcode.Ifeq : JvmOpcode.Ifne, labels.ifFalse);
			}
		}
		
		private void emitBoxing(ExpressionNode expression) {
			var generator = context.MethodGenerationContext.Generator;
			var info = expression.getUserData(typeof(ExpressionInfo));
			switch (info.BoxingKind) {
			case Box:
				generator.emit(JvmOpcode.Invokestatic, info.BoxingMethod);
				break;
			case Unbox:
				generator.emit(JvmOpcode.Invokevirtual, info.BoxingMethod);
				break;
			}
		}
		
		private void emitArguments(List<ExpressionNode> arguments, Iterable<JvmParameterInfo> parameters, int fixedLength,
				int nvarargs, boolean varargs) {
			var generator = context.MethodGenerationContext.Generator;
			var it1 = parameters.iterator();
			var it2 = arguments.iterator();
			int i;
			for (i = 0; i < fixedLength; i++) {
				var p = it1.next();
				var e = it2.next();
				var ei = e.getUserData(typeof(ExpressionInfo));
				if (ei != null && ei.Member != null && ei.Member.MemberKind == MemberKind.Method && ei.Method != null) {
					var thisExp = new ThisAccessExpressionNode();
					thisExp.addUserData(new ExpressionInfo(context.CurrentType));
					emitDelegateCreation(p.Type, ei.Method, thisExp, true);
				} else {
					handleExpression(e, null, true);
					if (p.Type.IsPrimitive) {
						emitImplicitCast(p.Type, e.getUserData(typeof(ExpressionInfo)).Type);
					}
				}
			}
			if (varargs) {
				if (nvarargs > 0) {
					var paramType = it1.next().Type;
					if (nvarargs == 1) {
						var e = arguments[i];
						var ei = e.getUserData(typeof(ExpressionInfo));
						if (ei == null) {
							generator.emit(JvmOpcode.Aconst_Null);
						} else if (ei.Type.IsArray && paramType.isAssignableFrom(ei.Type)) {
							handleExpression(e, null, true);
							if (paramType.IsPrimitive) {
								emitImplicitCast(paramType, e.getUserData(typeof(ExpressionInfo)).Type);
							}
						} else {
							BytecodeHelper.emitIntConstant(generator, 1);
							bytecodeGenerator.emitArray(1, paramType, it2);
						}
					} else {
						BytecodeHelper.emitIntConstant(generator, nvarargs);
						bytecodeGenerator.emitArray(1, paramType, it2);
					}
				} else {
					BytecodeHelper.emitIntConstant(generator, 0);
					bytecodeGenerator.emitArray(1, it1.next().Type, it2);
				}
			}
		}
		
		private void emitImplicitCast(JvmTypeInfo target, JvmTypeInfo source) {
			var generator = context.MethodGenerationContext.Generator;
			switch (target.TypeKind) {
			case Long:
				switch (source.TypeKind) {
				case Byte:
				case Short:
				case Char:
				case Int:
					generator.emit(JvmOpcode.I2l);
					break;
				case Float:
					generator.emit(JvmOpcode.F2l);
					break;
				case Double:
					generator.emit(JvmOpcode.D2l);
					break;
				}
				break;
			case Float:
				switch (source.TypeKind) {
				case Byte:
				case Short:
				case Char:
				case Int:
					generator.emit(JvmOpcode.I2f);
					break;
				case Long:
					generator.emit(JvmOpcode.L2f);
					break;
				case Double:
					generator.emit(JvmOpcode.D2f);
					break;
				}
				break;
			case Double:
				switch (source.TypeKind) {
				case Byte:
				case Short:
				case Char:
				case Int:
					generator.emit(JvmOpcode.I2d);
					break;
				case Long:
					generator.emit(JvmOpcode.L2d);
					break;
				case Float:
					generator.emit(JvmOpcode.F2d);
					break;
				}
				break;
			}
		}

		private void emitDelegateCreation(JvmTypeInfo delegateType, JvmMethodInfo method, ExpressionNode arg, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			if (arg != null) {
				var argType = arg.getUserData(typeof(ExpressionInfo)).Type;
				if (argType != null && BytecodeHelper.isDelegateType(argType)) {
					handleExpression(arg, null, nested);
					return;
				}
			}
			
			JvmMethodInfo invokeMethod = delegateType.Methods.where(p => p.Name.equals("invoke")).first();
			
			//
			// Delegate class creation
			//
			
			var currentType = (JvmTypeBuilder)context.CurrentType;
			var prefix = currentType.FullName + "$delegate";
			int n = currentType.NestedTypes.count(p => p.FullName.startsWith(prefix));
			var typeBuilder = currentType.defineNestedType("delegate" + n);
			context.TypeBuilders.add(typeBuilder);
			typeBuilder.setSynthetic(true);
			typeBuilder.setBaseType(delegateType);
			
			// invoke(...)
			var methodBuilder = typeBuilder.defineMethod("invoke");
			methodBuilder.setPublic(true);
			methodBuilder.setFinal(true);
			methodBuilder.setVarargs(invokeMethod.IsVarargs);
			methodBuilder.setReturnType(invokeMethod.ReturnType);
			foreach (var p in invokeMethod.Parameters) {
				var pb = methodBuilder.addParameter(p.Type);
				pb.setName(p.Name);
			}
			foreach (var t in invokeMethod.Exceptions) {
				methodBuilder.addException(t);
			}
			context.MethodGenerationContext.enterLambda(methodBuilder);
			
			var delegateTypeInfo = context.TypeSystem.getType("stab/lang/Delegate");
			
			var gen = methodBuilder.CodeGenerator;
			gen.beginScope();
			gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
			gen.emit(JvmOpcode.Getfield, delegateTypeInfo.getField("delegates"));
			var elseLabel = gen.defineLabel();
			gen.emit(JvmOpcode.Ifnull, elseLabel);
			
			gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
			gen.emit(JvmOpcode.Getfield, delegateTypeInfo.getField("delegates"));
			var td = gen.declareLocal(delegateTypeInfo.ArrayType, "td$0");
			gen.emit(JvmOpcode.Astore, td);
			JvmLocalInfo local = null;
			if (method.ReturnType != JvmTypeInfo.VOID) {
				local = gen.declareLocal(method.ReturnType, "result$0");
			}
			var idx = gen.declareLocal(JvmTypeInfo.INT, "i$0");
			gen.emit(JvmOpcode.Iconst_0);
			gen.emit(JvmOpcode.Istore, idx);
			var startLabel = gen.defineLabel();
			gen.markLabel(startLabel);
			gen.emit(JvmOpcode.Aload, td);
			gen.emit(JvmOpcode.Iload, idx);
			gen.emit(JvmOpcode.Aaload);
			gen.emit(JvmOpcode.Checkcast, delegateType);
			foreach (var p in invokeMethod.Parameters) {
				gen.emit(BytecodeHelper.getLoadOpcode(p.Type), gen.getLocal(p.Name));
			}
			gen.emit(JvmOpcode.Invokevirtual, invokeMethod);
			if (method.ReturnType != JvmTypeInfo.VOID) {
				var m = invokeMethod.OriginalMethodDefinition;
				BytecodeGenerator.emitGenericCast(context, invokeMethod.ReturnType, m.ReturnType);
				gen.emit(BytecodeHelper.getStoreOpcode(method.ReturnType), local);
			}
			gen.emit(JvmOpcode.Iinc, idx, 1);
			gen.emit(JvmOpcode.Iload, idx);
			gen.emit(JvmOpcode.Aload, td);
			gen.emit(JvmOpcode.Arraylength);
			gen.emit(JvmOpcode.If_icmplt, startLabel);
			if (method.ReturnType != JvmTypeInfo.VOID) {
				gen.emit(BytecodeHelper.getLoadOpcode(method.ReturnType), local);
			}
			gen.emit(BytecodeHelper.getReturnOpcode(method.ReturnType));
			gen.markLabel(elseLabel);
			if (!method.IsStatic) {
				gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
				gen.emit(JvmOpcode.Invokevirtual, delegateTypeInfo.getMethod("getTarget", Query.empty<JvmTypeInfo>()));
				gen.emit(JvmOpcode.Checkcast, method.DeclaringType);
			}
			foreach (var p in invokeMethod.Parameters) {
				gen.emit(BytecodeHelper.getLoadOpcode(p.Type), gen.getLocal(p.Name));
			}
			emitMethodAccess(method, false);
			gen.emit(BytecodeHelper.getReturnOpcode(method.ReturnType));
			gen.endScope();
			context.MethodGenerationContext.leaveLambda();

			if (invokeMethod.DeclaringType.GenericArguments.any()) {
				BytecodeGenerator.emitBridgeMethod(context, typeBuilder, methodBuilder, invokeMethod);
			}

			// getMethodCore()
			methodBuilder = typeBuilder.defineMethod("getMethodCore");
			methodBuilder.setProtected(true);
			methodBuilder.setFinal(true);
			methodBuilder.setReturnType(context.TypeSystem.getType("java/lang/reflect/Method"));

			gen = methodBuilder.CodeGenerator;
			gen.beginScope();
			var classType = context.TypeSystem.getType("java/lang/Class");
			BytecodeHelper.emitTypeof(gen, context.TypeSystem, method.DeclaringType);
			gen.emit(JvmOpcode.Ldc, method.Name);
			BytecodeHelper.emitIntConstant(gen, invokeMethod.Parameters.count());
			BytecodeHelper.emitNewarray(gen, 1, classType);

			int i = 0;
			foreach (var p in invokeMethod.Parameters) {
				gen.emit(JvmOpcode.Dup);
				BytecodeHelper.emitIntConstant(gen, i++);
				BytecodeHelper.emitTypeof(gen, context.TypeSystem, p.Type);
				gen.emit(JvmOpcode.Aastore);
			}
			
			var argTypes = new ArrayList<JvmTypeInfo>();
			argTypes.add(context.TypeSystem.getType("java/lang/String"));
			argTypes.add(classType.getGenericType(Collections.singletonList(JvmTypeInfo.UNBOUNDED_WILDCARD)).ArrayType);
			gen.emit(JvmOpcode.Invokevirtual, classType.getMethod("getMethod", argTypes));
			gen.emit(JvmOpcode.Areturn);
			gen.endScope();
			
			// getMethodSignature()
			methodBuilder = typeBuilder.defineMethod("getMethodSignature");
			methodBuilder.setProtected(true);
			methodBuilder.setFinal(true);
			var objectType = context.TypeSystem.ObjectType;
			methodBuilder.setReturnType(objectType);

			gen = methodBuilder.CodeGenerator;
			gen.beginScope();
			gen.emit(JvmOpcode.Ldc, method.DeclaringType.FullName + "." + method.Name + method.Descriptor);
			gen.emit(JvmOpcode.Areturn);
			gen.endScope();
			
			// Constructor T(object)
			methodBuilder = typeBuilder.defineMethod("<init>");
			methodBuilder.setProtected(true);
			methodBuilder.setReturnType(JvmTypeInfo.VOID);
			if (!method.IsStatic) {
				var parameterBuilder = methodBuilder.addParameter(objectType);
				parameterBuilder.setName("target");
			}

			var baseConstructor = typeBuilder.BaseType.getMethod("<init>", Collections.singletonList(objectType));
			gen = methodBuilder.CodeGenerator;
			gen.beginScope();
			gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
			if (method.IsStatic) {
				gen.emit(JvmOpcode.Aconst_Null);
			} else {
				gen.emit(JvmOpcode.Aload, gen.getLocal("target"));
			}
			gen.emit(JvmOpcode.Invokespecial, baseConstructor);
			gen.emit(JvmOpcode.Return);
			gen.endScope();


			//
			// Delegate object creation
			//
			
			generator.emit(JvmOpcode.New, typeBuilder);
			if (nested) {
				generator.emit(JvmOpcode.Dup);
			}
			if (!method.IsStatic) {
				handleExpression(arg, null, true);
			}
			generator.emit(JvmOpcode.Invokespecial, methodBuilder);
		}
		
		private void emitInterfaceCreation(JvmTypeInfo interfaceType, JvmMethodInfo method, ExpressionNode arg, boolean nested) {
			var generator = context.MethodGenerationContext.Generator;
			var currentType = (JvmTypeBuilder)context.CurrentType;
			var prefix = currentType.getFullName() + "$interface";
			int n = currentType.NestedTypes.count(p => p.FullName.startsWith(prefix));
			var typeBuilder = currentType.defineNestedType("interface" + n);
			context.TypeBuilders.add(typeBuilder);
			typeBuilder.setSynthetic(true);
			var objectType = context.TypeSystem.getType("java/lang/Object");
			typeBuilder.setBaseType(objectType);
			typeBuilder.addInterface(interfaceType);

			JvmFieldBuilder targetField = null;
			if (!method.IsStatic) {
				targetField = typeBuilder.defineField("target", method.DeclaringType);
				targetField.setPrivate(true);
			}

			var interfaceMethod = interfaceType.Methods.single();
			
			// Interface method
			var methodBuilder = typeBuilder.defineMethod(interfaceMethod.Name);
			methodBuilder.setPublic(true);
			methodBuilder.setFinal(true);
			methodBuilder.setVarargs(method.IsVarargs);
			methodBuilder.setReturnType(method.ReturnType);
			foreach (var p in method.Parameters) {
				var pb = methodBuilder.addParameter(p.Type);
				pb.setName(p.Name);
			}
			foreach (var t in method.Exceptions) {
				methodBuilder.addException(t);
			}
			
			var gen = methodBuilder.CodeGenerator;
			gen.beginScope();
			if (!method.IsStatic) {
				gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
				gen.emit(JvmOpcode.Getfield, targetField);
			}
			foreach (var p in method.Parameters) {
				gen.emit(BytecodeHelper.getLoadOpcode(p.getType()), gen.getLocal(p.getName()));
			}
			gen.emit((method.IsStatic) ? JvmOpcode.Invokestatic : JvmOpcode.Invokevirtual, method);
			gen.emit(BytecodeHelper.getReturnOpcode(method.ReturnType));
			gen.endScope();

			// Bridge
			if (interfaceMethod.DeclaringType.GenericArguments.any()) {
				BytecodeGenerator.emitBridgeMethod(context, typeBuilder, methodBuilder, interfaceMethod);
			}
			
			// Constructor T(scope)
			methodBuilder = typeBuilder.defineMethod("<init>");
			methodBuilder.setReturnType(JvmTypeInfo.VOID);
			if (!method.IsStatic) {
				var parameterBuilder = methodBuilder.addParameter(method.DeclaringType);
				parameterBuilder.setName("target");
			}

			var baseConstructor = objectType.getMethod("<init>", Query.empty<JvmTypeInfo>());
			gen = methodBuilder.CodeGenerator;
			gen.beginScope();
			gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
			gen.emit(JvmOpcode.Invokespecial, baseConstructor);
			if (!method.IsStatic) {
				gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
				gen.emit(JvmOpcode.Aload, gen.getLocal("target"));
				gen.emit(JvmOpcode.Putfield, targetField);
			}
			gen.emit(JvmOpcode.Return);
			gen.endScope();
			
			//
			// Interface object creation
			//
			
			generator.emit(JvmOpcode.New, typeBuilder);
			if (nested) {
				generator.emit(JvmOpcode.Dup);
			}
			if (!method.IsStatic) {
				handleExpression(arg, null, true);
			}
			generator.emit(JvmOpcode.Invokespecial, methodBuilder);
		}
		
		private void emitMethodAccess(JvmMethodInfo method, boolean isSuperCall) {
			var generator = context.MethodGenerationContext.Generator;
			if (BytecodeGenerator.requireAccessor(context, method.DeclaringType, method.IsPublic, method.IsProtected, method.IsPrivate)) {
				var accessor = context.PrivateAccessors[method];
				if (accessor == null) {
					var outerClass = (JvmTypeBuilder)context.MethodGenerationContext.CurrentMethod.DeclaringType;
					while ((outerClass = (JvmTypeBuilder)outerClass.DeclaringType) != null) {
						if (method.DeclaringType.isAssignableFrom(outerClass)) {
							break;
						}
					}
					int n = outerClass.Methods.count(p => p.Name.startsWith("access$"));
					var methodBuilder = outerClass.defineMethod("access$" + n);
					methodBuilder.setReturnType(method.ReturnType);
					methodBuilder.setStatic(method.IsStatic);
					methodBuilder.setFinal(!method.IsStatic);
					methodBuilder.setSynthetic(true);
					methodBuilder.setVarargs(method.IsVarargs);
					foreach (var p in method.Parameters) {
						var pb = methodBuilder.addParameter(p.Type);
						pb.setName(p.Name);
					}
					foreach (var t in method.Exceptions) {
						methodBuilder.addException(t);
					}
					var gen = methodBuilder.CodeGenerator;
					gen.beginScope();
					if (!method.IsStatic) {
						gen.emit(JvmOpcode.Aload, gen.getLocal("this"));
					}
					foreach (var p in method.Parameters) {
						gen.emit(BytecodeHelper.getLoadOpcode(p.Type), gen.getLocal(p.Name));
					}
					if (method.IsStatic) {
						gen.emit(JvmOpcode.Invokestatic, method);
					} else {
						gen.emit(JvmOpcode.Invokevirtual, method);
					}
					gen.emit(BytecodeHelper.getReturnOpcode(method.ReturnType));
					gen.endScope();
					accessor = methodBuilder;
					context.PrivateAccessors[method] = accessor;
				}
				method = accessor;
			}
			if (method.IsStatic) {
				generator.emit(JvmOpcode.Invokestatic, method);
			} else if (method.IsConstructor) {
				generator.emit(JvmOpcode.Invokespecial, method);
			} else if (method.DeclaringType.IsInterface) {
				generator.emit(JvmOpcode.Invokeinterface, method);
			} else {
				if (isSuperCall) {
					generator.emit(JvmOpcode.Invokespecial, method);
				} else {
					generator.emit(JvmOpcode.Invokevirtual, method);
				}
			}
		}
		
		private void emitOperands(ExpressionNode left, boolean leftIsZero, ExpressionNode right, boolean rightIsZero) {
			var generator = context.MethodGenerationContext.Generator;
			var li = left.getUserData(typeof(ExpressionInfo));
			var ri = right.getUserData(typeof(ExpressionInfo));
			
			switch (li.Type.TypeKind) {
			case Byte:
			case Char:
			case Short:
			case Int: {
				switch (ri.Type.TypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
					}
					break;
				}
				case Long: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
						generator.emit(JvmOpcode.I2l);
					}
					break;
				}
				case Float: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
						generator.emit(JvmOpcode.I2f);
					}
					break;
				}
				case Double: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
						generator.emit(JvmOpcode.I2d);
					}
					break;
				}
				}
				if (!rightIsZero) {
					handleExpression(right, null, true);
				}
				break;
			}
			case Long: {
				switch (ri.Type.TypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
						generator.emit(JvmOpcode.I2l);
					}
					break;
				}
				case Long: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
					}
					break;
				}
				case Float: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
						generator.emit(JvmOpcode.L2f);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
					}
					break;
				}
				case Double: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
						generator.emit(JvmOpcode.L2d);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
					}
					break;
				}
				}
				break;
			}
			case Float: {
				switch (ri.Type.TypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
						generator.emit(JvmOpcode.I2f);
					}
					break;
				}
				case Long: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
						generator.emit(JvmOpcode.L2f);
					}
					break;
				}
				case Float: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
					}
					break;
				}
				case Double: {
					if (!leftIsZero) {
						handleExpression(left, null, true);
						generator.emit(JvmOpcode.F2d);
					}
					if (!rightIsZero) {
						handleExpression(right, null, true);
					}
					break;
				}
				}
				break;
			}
			case Double: {
				if (!leftIsZero) {
					handleExpression(left, null, true);
				}
				switch (ri.Type.TypeKind) {
				case Byte:
				case Char:
				case Short:
				case Int: {
					if (!rightIsZero) {
						handleExpression(right, null, true);
						generator.emit(JvmOpcode.I2d);
					}
					break;
				}
				case Long: {
					if (!rightIsZero) {
						handleExpression(right, null, true);
						generator.emit(JvmOpcode.L2d);
					}
					break;
				}
				case Float: {
					if (!rightIsZero) {
						handleExpression(right, null, true);
						generator.emit(JvmOpcode.F2d);
					}
					break;
				}
				case Double: {
					if (!rightIsZero) {
						handleExpression(right, null, true);
					}
					break;
				}
				}
				break;
			}
			default:
				handleExpression(left, null, true);
				handleExpression(right, null, true);
				break;
			}
		}
		
		private void emitComparison(BinaryExpressionNode binary, boolean leftIsZero, boolean rightIsZero,
				JvmOpcode ifLeftZero, JvmOpcode ifRightZero, JvmOpcode intOperation, JvmLabelMarker elseLabel) {
			var generator = context.MethodGenerationContext.Generator;
			switch (binary.getUserData(typeof(JvmTypeInfo)).TypeKind) {
			case Byte:
			case Char:
			case Short:
			case Int:
				emitOperands(binary.LeftOperand, leftIsZero, binary.RightOperand, rightIsZero);
				if (rightIsZero) {
					generator.emit(ifRightZero, elseLabel);
				} else if (leftIsZero) {
					generator.emit(ifLeftZero, elseLabel);
				} else {
					generator.emit(intOperation, elseLabel);
				}
				break;
			case Long:
				if (leftIsZero) {
					generator.emit(JvmOpcode.Lconst_0);
				}
				emitOperands(binary.LeftOperand, leftIsZero, binary.RightOperand, rightIsZero);
				if (rightIsZero) {
					generator.emit(JvmOpcode.Lconst_0);
				}
				generator.emit(JvmOpcode.Lcmp);
				generator.emit(ifRightZero, elseLabel);
				break;
			case Float:
				if (leftIsZero) {
					generator.emit(JvmOpcode.Fconst_0);
				}
				emitOperands(binary.LeftOperand, leftIsZero, binary.RightOperand, rightIsZero);
				if (rightIsZero) {
					generator.emit(JvmOpcode.Fconst_0);
				}
				generator.emit((ifRightZero == JvmOpcode.Ifgt || ifRightZero == JvmOpcode.Ifge) ? JvmOpcode.Fcmpg : JvmOpcode.Fcmpl);
				generator.emit(ifRightZero, elseLabel);
				break;
			case Double:
				if (leftIsZero) {
					generator.emit(JvmOpcode.Dconst_0);
				}
				emitOperands(binary.LeftOperand, leftIsZero, binary.RightOperand, rightIsZero);
				if (rightIsZero) {
					generator.emit(JvmOpcode.Dconst_0);
				}
				generator.emit((ifRightZero == JvmOpcode.Ifgt || ifRightZero == JvmOpcode.Ifge) ? JvmOpcode.Dcmpg : JvmOpcode.Dcmpl);
				generator.emit(ifRightZero, elseLabel);
				break;
			default:
				throw new Exception("Internal error");
			}
		}
		
		private void emitEquality(BinaryExpressionNode binary, boolean leftIsZero, boolean rightIsZero, JvmLabelMarker label, boolean negate) {
			var generator = context.MethodGenerationContext.Generator;
			JvmTypeInfo type = binary.getUserData(typeof(JvmTypeInfo));
			switch (type.TypeKind) {
			case Boolean:
			case Byte:
			case Char:
			case Short:
			case Int:
				emitOperands(binary.getLeftOperand(), leftIsZero, binary.getRightOperand(), rightIsZero);
				if (leftIsZero || rightIsZero) {
					generator.emit((negate) ? JvmOpcode.Ifne : JvmOpcode.Ifeq, label);
				} else {
					generator.emit((negate) ? JvmOpcode.If_icmpne : JvmOpcode.If_icmpeq, label);
				}
				break;
			case Long:
				emitOperands(binary.getLeftOperand(), false, binary.getRightOperand(), false);
				generator.emit(JvmOpcode.Lcmp);
				generator.emit((negate) ? JvmOpcode.Ifne : JvmOpcode.Ifeq, label);
				break;
			case Float:
				emitOperands(binary.getLeftOperand(), false, binary.getRightOperand(), false);
				generator.emit(JvmOpcode.Fcmpg);
				generator.emit((negate) ? JvmOpcode.Ifne : JvmOpcode.Ifeq, label);
				break;
			case Double:
				emitOperands(binary.getLeftOperand(), false, binary.getRightOperand(), false);
				generator.emit(JvmOpcode.Dcmpg);
				generator.emit((negate) ? JvmOpcode.Ifne : JvmOpcode.Ifeq, label);
				break;
			default:
				var li = binary.getLeftOperand().getUserData(typeof(ExpressionInfo));
				var ri = binary.getRightOperand().getUserData(typeof(ExpressionInfo));
				if (li == null) {
					handleExpression(binary.getRightOperand(), null, true);
					generator.emit((negate) ? JvmOpcode.Ifnonnull : JvmOpcode.Ifnull, label);
				} else if (ri == null) {
					handleExpression(binary.getLeftOperand(), null, true);
					generator.emit((negate) ? JvmOpcode.Ifnonnull : JvmOpcode.Ifnull, label);
				} else {
					handleExpression(binary.getLeftOperand(), null, true);
					handleExpression(binary.getRightOperand(), null, true);
					generator.emit((negate) ? JvmOpcode.If_acmpne : JvmOpcode.If_acmpeq, label);
				}
				break;
			}
		}

	}
}
