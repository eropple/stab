/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.lang;
using java.util;
using stab.query;
using stab.tools.bytecode;
using stab.tools.syntaxtree;
 
package stab.tools.compiler {

    class ExpressionTreeGenerator : StatementHandler<Void, Void> {
        private CompilerContext context;
        private ExpressionGenerator expressionGenerator;
        private JvmTypeInfo expressionType;
        private JvmTypeInfo statementType;
        private JvmTypeInfo binaryOperatorType;
        private JvmTypeInfo unaryOperatorType;
        private JvmTypeInfo unboundedConstructorType;
        private JvmTypeInfo memberInitializerType;
        private JvmMethodInfo expressionMethod;
        private JvmMethodInfo valueMethod;
        private JvmMethodInfo getDeclaredMethodMethod;
        private JvmMethodInfo getDeclaredFieldMethod;
        private JvmMethodInfo getDeclaredConstructorMethod;
        private JvmMethodInfo callMethod;
        private JvmMethodInfo invokeMethod;
        private JvmMethodInfo parameterMethod;
        private JvmMethodInfo lambdaMethod;
        private JvmMethodInfo treeMethod;
        private JvmMethodInfo fieldMethod;
        private JvmMethodInfo binaryMethod;
        private JvmMethodInfo unaryMethod;
        private JvmMethodInfo conditionalMethod;
        private JvmMethodInfo newObjectMethod;
        private JvmMethodInfo newArrayMethod;
        private JvmMethodInfo memberInitializerConstructor;
    
        ExpressionTreeGenerator(CompilerContext context)
            : super(true) {
            this.context = context;
            this.expressionGenerator = new ExpressionGenerator(this, context);
        }
        
        #region Reflection cache
        
        JvmTypeInfo ExpressionType {
            get {
                if (expressionType == null) {
                    expressionType = context.TypeSystem.getType("stab/tree/Expression");
                }
                return expressionType;
            }
        }
        
        JvmTypeInfo StatementType {
            get {
                if (statementType == null) {
                    statementType = context.TypeSystem.getType("stab/tree/Statement");
                }
                return statementType;
            }
        }
        
        JvmTypeInfo UnaryOperatorType {
            get {
                if (unaryOperatorType == null) {
                    unaryOperatorType = context.TypeSystem.getType("stab/tree/UnaryOperator");
                }
                return unaryOperatorType;
            }
        }
        
        JvmTypeInfo BinaryOperatorType {
            get {
                if (binaryOperatorType == null) {
                    binaryOperatorType = context.TypeSystem.getType("stab/tree/BinaryOperator");
                }
                return binaryOperatorType;
            }
        }
        
        JvmTypeInfo UnboundedConstructorType {
            get {
                if (unboundedConstructorType == null) {
                    var type = context.TypeSystem.getType("java/lang/reflect/Constructor");
                    unboundedConstructorType = type.getGenericType(Query.singleton(JvmTypeInfo.UNBOUNDED_WILDCARD));
                }
                return unboundedConstructorType;
            }
        }
        
        JvmTypeInfo MemberInitializerType {
            get {
                if (memberInitializerType == null) {
                    memberInitializerType = context.TypeSystem.getType("stab/tree/MemberInitializer");
                }
                return memberInitializerType;
            }
        }
        
        JvmMethodInfo ExpressionMethod {
            get {
                if (expressionMethod == null) {
                    expressionMethod = this.StatementType.getMethod("expression", Query.singleton(this.ExpressionType));
                }
                return expressionMethod;
            }
        }

        JvmMethodInfo ValueMethod {
            get {
                if (valueMethod == null) {
                    var parameters = Query.pair(context.TypeSystem.UnboundedClassType, context.TypeSystem.ObjectType);
                    valueMethod = this.ExpressionType.getMethod("value", parameters);
                }
                return valueMethod;
            }
        }
        
        JvmMethodInfo GetDeclaredMethodMethod {
            get {
                if (getDeclaredMethodMethod == null) {
                    var parameters = Query.pair(context.TypeSystem.StringType, context.TypeSystem.UnboundedClassType.ArrayType);
                    getDeclaredMethodMethod = context.TypeSystem.ClassType.getMethod("getDeclaredMethod", parameters);
                }
                return getDeclaredMethodMethod;
            }
        }
        
        JvmMethodInfo GetDeclaredFieldMethod {
            get {
                if (getDeclaredFieldMethod == null) {
                    var parameters = Query.singleton(context.TypeSystem.StringType);
                    getDeclaredFieldMethod = context.TypeSystem.ClassType.getMethod("getDeclaredField", parameters);
                }
                return getDeclaredFieldMethod;
            }
        }
        
        JvmMethodInfo GetDeclaredConstructorMethod {
            get {
                if (getDeclaredConstructorMethod == null) {
                    var parameters = Query.singleton(context.TypeSystem.UnboundedClassType.ArrayType);
                    getDeclaredConstructorMethod = context.TypeSystem.ClassType.getMethod("getDeclaredConstructor", parameters);
                }
                return getDeclaredConstructorMethod;
            }
        }

        JvmMethodInfo CallMethod {
            get {
                if (callMethod == null) {
                    var parameters = Query.triple(this.ExpressionType, this.GetDeclaredMethodMethod.ReturnType, this.ExpressionType.ArrayType);
                    callMethod = this.ExpressionType.getMethod("call", parameters);
                }
                return callMethod;
            }
        }
        
        JvmMethodInfo InvokeMethod {
            get {
                if (invokeMethod == null) {
                    var parameters = Query.pair(this.ExpressionType, this.ExpressionType.ArrayType);
                    invokeMethod = this.ExpressionType.getMethod("invoke", parameters);
                }
                return invokeMethod;
            }
        }
        
        JvmMethodInfo ParameterMethod {
            get {
                if (parameterMethod == null) {
                    var parameters = Query.pair(context.TypeSystem.UnboundedClassType, context.TypeSystem.StringType);
                    parameterMethod = this.ExpressionType.getMethod("parameter", parameters);
                }
                return parameterMethod;
            }
        }

        JvmMethodInfo LambdaMethod {
            get {
                if (lambdaMethod == null) {
                    lambdaMethod = this.ExpressionType.Methods.where(p => p.Name.equals("lambda")).single();
                }
                return lambdaMethod;
            }
        }

        JvmMethodInfo TreeMethod {
            get {
                if (treeMethod == null) {
                    treeMethod = this.ExpressionType.Methods.where(p => p.Name.equals("tree")).single();
                }
                return treeMethod;
            }
        }

        JvmMethodInfo FieldMethod {
            get {
                if (fieldMethod == null) {
                    var parameters = Query.pair(this.ExpressionType, this.GetDeclaredFieldMethod.ReturnType);
                    fieldMethod = this.ExpressionType.getMethod("field", parameters);
                }
                return fieldMethod;
            }
        }
        
        JvmMethodInfo BinaryMethod {
            get {
                if (binaryMethod == null) {
                    var parameters = Query.quadruple(context.TypeSystem.UnboundedClassType,
                            this.ExpressionType, this.BinaryOperatorType, this.ExpressionType);
                    binaryMethod = this.ExpressionType.getMethod("binary", parameters);
                }
                return binaryMethod;
            }
        }
        
        JvmMethodInfo UnaryMethod {
            get {
                if (unaryMethod == null) {
                    var parameters = Query.triple(context.TypeSystem.UnboundedClassType, this.UnaryOperatorType, this.ExpressionType);
                    unaryMethod = this.ExpressionType.getMethod("unary", parameters);
                }
                return unaryMethod;
            }
        }
        
        JvmMethodInfo ConditionalMethod {
            get {
                if (conditionalMethod == null) {
                    var parameters = Query.quadruple(context.TypeSystem.UnboundedClassType,
                            this.ExpressionType, this.ExpressionType, this.ExpressionType);
                    conditionalMethod = this.ExpressionType.getMethod("conditional", parameters);
                }
                return conditionalMethod;
            }
        }

        JvmMethodInfo NewObjectMethod {
            get {
                if (newObjectMethod == null) {
                    var parameters = Query.triple(this.UnboundedConstructorType, this.ExpressionType.ArrayType,
                            this.MemberInitializerType.ArrayType);
                    newObjectMethod = this.ExpressionType.getMethod("newObject", parameters);
                }
                return newObjectMethod;
            }
        }

        JvmMethodInfo NewArrayMethod {
            get {
                if (newArrayMethod == null) {
                    var parameters = Query.quadruple(context.TypeSystem.UnboundedClassType, this.ExpressionType.ArrayType,
                            JvmTypeInfo.INT, this.ExpressionType.ArrayType);
                    newArrayMethod = this.ExpressionType.getMethod("newArray", parameters);
                }
                return newArrayMethod;
            }
        }

        JvmMethodInfo MemberInitializerConstructor {
            get {
                if (memberInitializerConstructor == null) {
                    memberInitializerConstructor = this.MemberInitializerType.Methods.where(p => p.Name.equals("<init>")).single();
                }
                return memberInitializerConstructor;
            }
        }
        
        #endregion
        
        void generateExpressionTree(LambdaExpressionNode lambda) {
            expressionGenerator.handleExpression(lambda, null, false);
        }
        
        protected override Void handleExpression(ExpressionStatementNode expression, Void source) {
            var info = expression.getUserData(typeof(StatementInfo));
            if (info == null) {
                return null;
            }
            var generator = context.MethodGenerationContext.Generator;
            expressionGenerator.handleExpression(expression.Expression, null, true);
            generator.emit(JvmOpcode.Invokestatic, this.ExpressionMethod);
            return null;
        }
        
        void emitThisAccess(CompilerContext context, JvmCodeGenerator generator) {
            BytecodeHelper.emitTypeof(generator, context.TypeSystem, context.MethodGenerationContext.CurrentMethod.DeclaringType);
            BytecodeGenerator.emitThisAccess(context, generator);
            generator.emit(JvmOpcode.Invokestatic, this.ValueMethod);
        }
        
        void emitArray(int dimensions, JvmTypeInfo type, Iterator<ExpressionNode> values) {
            var generator = context.MethodGenerationContext.Generator;
            BytecodeHelper.emitNewarray(generator, dimensions, type.ElementType);
            if (values != null) {
                var opcode = BytecodeHelper.getAstoreOpcode(type.ElementType);
                int i = 0;
                while (values.hasNext()) {
                    var e = values.next();
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    expressionGenerator.handleExpression(e, null, true);
                    generator.emit(opcode);
                }
            }
        }
            
        private class ExpressionGenerator : ExpressionHandler<Void, Void> {
            private ExpressionTreeGenerator statementGenerator;
            private CompilerContext context;
        
            ExpressionGenerator(ExpressionTreeGenerator statementGenerator, CompilerContext context)
                : super(true) {
                this.statementGenerator = statementGenerator;
                this.context = context;
            }
            
            public override Void handleExpression(ExpressionNode expression, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = expression.getUserData(typeof(ExpressionInfo));
                if (info == null) {
                    emitNull();
                    return null;
                }
                if (!info.IsConstant) {
                    return super.handleExpression(expression, null, nested);
                }
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                var value = info.Value;
                switch (info.Type.TypeKind) {
                case Boolean:
                    if (((Boolean)value).booleanValue()) {
                        generator.emit(JvmOpcode.Iconst_1);
                    } else {
                        generator.emit(JvmOpcode.Iconst_0);
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;
                case Char:
                case Byte:
                case Short:
                case Int:
                    BytecodeHelper.emitIntConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Long:
                    BytecodeHelper.emitLongConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Float:
                    BytecodeHelper.emitFloatConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Double:
                    BytecodeHelper.emitDoubleConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                default:
                    generator.emit(JvmOpcode.Ldc, value);
                    break;
                }
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
                return null;
            }

            protected override Void handleAnonymousObjectCreation(AnonymousObjectCreationExpressionNode anonymousObject,
                    Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var typeInfo = anonymousObject.getUserData(typeof(ExpressionInfo)).Type;
                var constructor = typeInfo.Methods.where(p => p.Name.equals("<init>")).first();
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, typeInfo);
                BytecodeHelper.emitIntConstant(generator, constructor.Parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                int i = 0;
                foreach (var p in constructor.Parameters) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                    generator.emit(JvmOpcode.Aastore);
                }
                generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredConstructorMethod);
                
                BytecodeHelper.emitIntConstant(generator, constructor.Parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                i = 0;
                foreach (var decl in anonymousObject.MemberDeclarators) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    handleExpression(decl.Value, null, true);
                    generator.emit(JvmOpcode.Aastore);
                }
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.NewObjectMethod);
                return null;
            }

            protected override Void handleArrayCreation(ArrayCreationExpressionNode arrayCreation, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var type = arrayCreation.getUserData(typeof(ExpressionInfo)).Type;
                var initializer = arrayCreation.Initializer;
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, type);
                if (arrayCreation.DimensionExpressions.size() == 0) {
                    generator.emit(JvmOpcode.Aconst_Null);
                } else {
                    BytecodeHelper.emitIntConstant(generator, arrayCreation.DimensionExpressions.size());
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    int i = 0;
                    foreach (var e in arrayCreation.DimensionExpressions) {
                        generator.emit(JvmOpcode.Dup);
                        BytecodeHelper.emitIntConstant(generator, i++);
                        handleExpression(e, null, true);
                        generator.emit(JvmOpcode.Aastore);
                    }
                }
                BytecodeHelper.emitIntConstant(generator, arrayCreation.Dimensions);
                if (initializer == null) {
                    generator.emit(JvmOpcode.Aconst_Null);
                } else {
                    BytecodeHelper.emitIntConstant(generator, initializer.Values.size());
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    int i = 0;
                    foreach (var e in initializer.Values) {
                        generator.emit(JvmOpcode.Dup);
                        BytecodeHelper.emitIntConstant(generator, i++);
                        handleExpression(e, null, true);
                        generator.emit(JvmOpcode.Aastore);
                    }
                }
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.NewArrayMethod);
                return null;
            }
            
            protected override Void handleAssign(AssignExpressionNode assign, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = assign.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                handleExpression(assign.Left, null, true);
                var op = (assign.Operator.equals("Assign")) ? "Assign" : assign.Operator.toString() + "Assign";
                generator.emit(JvmOpcode.Getstatic, statementGenerator.BinaryOperatorType.getField(op));
                handleExpression(assign.Right, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.BinaryMethod);
                return null;
            }
            
            protected override Void handleBinary(BinaryExpressionNode binary, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = binary.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                handleExpression(binary.LeftOperand, null, true);
                generator.emit(JvmOpcode.Getstatic, statementGenerator.BinaryOperatorType.getField(binary.Operator.toString()));
                handleExpression(binary.RightOperand, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.BinaryMethod);
                return null;
            }

            protected override Void handleCast(CastExpressionNode cast, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = cast.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                generator.emit(JvmOpcode.Getstatic, statementGenerator.UnaryOperatorType.getField("Cast"));
                handleExpression(cast.Expression, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.UnaryMethod);
                return null;
            }

            protected override Void handleConditional(ConditionalExpressionNode conditional, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = conditional.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                handleExpression(conditional.Condition, null, true);
                handleExpression(conditional.IfTrue, null, true);
                handleExpression(conditional.IfFalse, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ConditionalMethod);
                return null;
            }
            
            protected override Void handleElementAccess(ElementAccessExpressionNode elementAccess, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = elementAccess.getUserData(typeof(ExpressionInfo));
                var target = elementAccess.TargetObject;
                var tinfo = target.getUserData(typeof(ExpressionInfo));
                var ttype = tinfo.Type;
                if (!ttype.IsArray) {
                    var method = elementAccess.getUserData(typeof(ExpressionInfo)).Member.GetAccessor.OriginalMethodDefinition;
                    if (!method.IsStatic) {
                        handleExpression(target, null, true);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    BytecodeHelper.emitIntConstant(generator, 1);
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, method.Parameters.first().Type);
                    generator.emit(JvmOpcode.Aastore);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);

                    BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    var arguments = elementAccess.Indexes;
                    emitArguments(arguments, method.Parameters, method.Parameters.count(), method.IsVarargs);
                    
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                } else {
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                    handleExpression(target, null, true);
                    generator.emit(JvmOpcode.Getstatic, statementGenerator.BinaryOperatorType.getField("Element"));
                    var index = elementAccess.Indexes[0];
                    handleExpression(index, null, true);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.BinaryMethod);
                }
                return null;
            }
            
            protected override Void handleInvocation(InvocationExpressionNode invocation, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = invocation.getUserData(typeof(ExpressionInfo));
                var method = info.Method;
                if (method.IsExcludedFromCompilation || CompilerHelper.shouldIgnoreCalls(context, method)) {
                    return null;
                }
                method = method.OriginalMethodDefinition;
                var isDelegateInvocation = BytecodeHelper.isDelegateType(method.DeclaringType) && method.Name.equals("invoke");
                if (!method.IsStatic) {
                    if (isDelegateInvocation) {
                        handleExpression(invocation.TargetObject, null, true);
                    } else if (invocation.TargetObject.ExpressionKind == ExpressionKind.MemberAccess) {
                        var targetTarget = ((MemberAccessExpressionNode)invocation.TargetObject).TargetObject;
                        handleExpression(targetTarget, null, true);
                    } else { // SimpleName
                        statementGenerator.emitThisAccess(context, generator);
                    }
                } else {
                    emitNull();
                }
                if (!isDelegateInvocation) {
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    
                    BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    int i = 0;
                    foreach (var p in method.Parameters) {
                        generator.emit(JvmOpcode.Dup);
                        BytecodeHelper.emitIntConstant(generator, i++);
                        BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                        generator.emit(JvmOpcode.Aastore);
                    }
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                }
                
                BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                
                var arguments = invocation.Arguments;
                if (info.IsExtension) {
                    var target = (MemberAccessExpressionNode)invocation.TargetObject;
                    arguments = new ArrayList<ExpressionNode> { target.TargetObject };
                    arguments.addAll(invocation.Arguments);
                }
                emitArguments(arguments, method.Parameters, method.Parameters.count(), method.IsVarargs);
                if (!isDelegateInvocation) {
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                } else {
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.InvokeMethod);
                }
                return null;
            }
            
            protected override Void handleLambda(LambdaExpressionNode lambda, Void source, boolean nested) {
                var methodBuilder = lambda.getUserData(typeof(JvmMethodBuilder));
                ((JvmTypeBuilder)methodBuilder.DeclaringType).undefineMethod(methodBuilder);
                
                var info = lambda.getUserData(typeof(ExpressionInfo));
                
                var generator = context.MethodGenerationContext.Generator;
                generator.beginScope();
                var parameterExpressionType = statementGenerator.ParameterMethod.ReturnType;
                var parameters = new ArrayList<JvmLocalInfo>();
                foreach (var pi in methodBuilder.Parameters) {
                    var local = generator.declareLocal(parameterExpressionType, "tree$local" + context.MethodGenerationContext.nextGeneratedLocal());
                    parameters.add(local);
                    context.MethodGenerationContext.TreeLocals[pi.getUserData(typeof(LocalInfo))] = local;
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, pi.Type);
                    generator.emit(JvmOpcode.Ldc, pi.Name);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.ParameterMethod);
                    generator.emit(JvmOpcode.Astore, local);
                }
                var method = (nested) ? statementGenerator.LambdaMethod : statementGenerator.TreeMethod;
                if (info.Type.FullName.equals("stab/tree/ExpressionTree")) {
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type.GenericArguments.single());
                } else {
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                }
                BytecodeHelper.emitIntConstant(generator, parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, parameterExpressionType);
                int i = 0;
                foreach (var p in parameters) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    generator.emit(JvmOpcode.Aload, p);
                    generator.emit(JvmOpcode.Aastore);
                }
                
                statementGenerator.handleStatement(lambda.Body, null);
                generator.emit(JvmOpcode.Invokestatic, method);
                generator.endScope();
                return null;
            }
            
            protected override Void handleMemberAccess(MemberAccessExpressionNode memberAccess, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = memberAccess.getUserData(typeof(ExpressionInfo));
                if (info.Method != null) {
                    emitDelegateCreation(info.Type, info.Method, memberAccess, nested);
                    return null;
                }
                var member = info.Member;
                if (member == null) {
                    handleExpression(memberAccess.TargetObject, null, true);
                    return null;
                }
                switch (member.MemberKind) {
                case Field: {
                    var field = member.Field;
                    if (!field.IsStatic) {
                        handleExpression(memberAccess.TargetObject, null, true);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, field.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, field.Name);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredFieldMethod);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.FieldMethod);
                    break;
                }
                case Property: {
                    var method = member.GetAccessor;
                    if (!method.IsStatic) {
                        handleExpression(memberAccess.TargetObject, null, true);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                    break;
                }
                default:
                    throw new Exception("Internal error: unhandled name kind: " + member.MemberKind);
                }
                return null;
            }
            
            protected override Void handleObjectCreation(ObjectCreationExpressionNode objectCreation, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = objectCreation.getUserData(typeof(ExpressionInfo));
                var method = info.Method;
                if (BytecodeHelper.isDelegateType(info.Type)) {
                    emitDelegateCreation(info.Type, method, objectCreation.Arguments[0], nested);
                    return null;
                }
                int nparams = method.Parameters.count();
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                BytecodeHelper.emitIntConstant(generator, nparams);
                BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                int i = 0;
                foreach (var p in method.Parameters) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                    generator.emit(JvmOpcode.Aastore);
                }
                generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredConstructorMethod);
                BytecodeHelper.emitIntConstant(generator, nparams);
                BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                var arguments = objectCreation.Arguments;
                emitArguments(arguments, method.Parameters, method.Parameters.count(), method.IsVarargs);
                var init = objectCreation.Initializer;
                if (init == null) {
                    generator.emit(JvmOpcode.Aconst_Null);
                } else {
                    if (init.ExpressionKind == ExpressionKind.ObjectInitializer) {
                        var initializer = (ObjectInitializerExpressionNode)init;
                        BytecodeHelper.emitIntConstant(generator, initializer.MemberInitializers.size());
                        BytecodeHelper.emitNewarray(generator, 1, statementGenerator.MemberInitializerType);
                        i = 0;
                        foreach (var mi in initializer.MemberInitializers) {
                            generator.emit(JvmOpcode.Dup);
                            BytecodeHelper.emitIntConstant(generator, i++);
                            MemberInfo memb = mi.getUserData(typeof(MemberInfo));
                            generator.emit(JvmOpcode.New, statementGenerator.MemberInitializerType);
                            generator.emit(JvmOpcode.Dup);
                            BytecodeHelper.emitTypeof(generator, context.TypeSystem, memb.DeclaringType);
                            if (memb.MemberKind == MemberKind.Property) {
                                var meth = memb.SetAccessor;
                                generator.emit(JvmOpcode.Ldc, meth.getName());
                                nparams = meth.Parameters.count();
                                BytecodeHelper.emitIntConstant(generator, nparams);
                                BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                                i = 0;
                                foreach (var p in meth.Parameters) {
                                    generator.emit(JvmOpcode.Dup);
                                    BytecodeHelper.emitIntConstant(generator, i++);
                                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                                    generator.emit(JvmOpcode.Aastore);
                                }
                                generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                            } else {
                                generator.emit(JvmOpcode.Ldc, memb.Name);
                                generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredFieldMethod);
                            }
                            BytecodeHelper.emitIntConstant(generator, 1);
                            BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                            generator.emit(JvmOpcode.Dup);
                            BytecodeHelper.emitIntConstant(generator, 0);
                            handleExpression(mi.Value, null, true);
                            generator.emit(JvmOpcode.Aastore);
                            generator.emit(JvmOpcode.Invokespecial, statementGenerator.MemberInitializerConstructor);
                            generator.emit(JvmOpcode.Aastore);
                        }
                    } else {
                        var initializer = (CollectionInitializerExpressionNode)init;
                        var addMethod = initializer.getUserData(typeof(JvmMethodInfo)).OriginalMethodDefinition;
                        BytecodeHelper.emitIntConstant(generator, initializer.Values.size());
                        BytecodeHelper.emitNewarray(generator, 1, statementGenerator.MemberInitializerType);
                        i = 0;
                        foreach (var args in initializer.Values) {
                            generator.emit(JvmOpcode.Dup);
                            BytecodeHelper.emitIntConstant(generator, i++);
                            generator.emit(JvmOpcode.New, statementGenerator.MemberInitializerType);
                            generator.emit(JvmOpcode.Dup);
                            BytecodeHelper.emitTypeof(generator, context.TypeSystem, addMethod.DeclaringType);
                            generator.emit(JvmOpcode.Ldc, addMethod.getName());
                            nparams = addMethod.Parameters.count();
                            BytecodeHelper.emitIntConstant(generator, nparams);
                            BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                            i = 0;
                            foreach (var p in addMethod.Parameters) {
                                generator.emit(JvmOpcode.Dup);
                                BytecodeHelper.emitIntConstant(generator, i++);
                                BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                                generator.emit(JvmOpcode.Aastore);
                            }
                            generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                            BytecodeHelper.emitIntConstant(generator, args.size());
                            BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                            int j = 0;
                            foreach (var e in args) {
                                generator.emit(JvmOpcode.Dup);
                                BytecodeHelper.emitIntConstant(generator, j++);
                                handleExpression(e, null, true);
                                generator.emit(JvmOpcode.Aastore);
                            }
                            generator.emit(JvmOpcode.Invokespecial, statementGenerator.MemberInitializerConstructor);
                            generator.emit(JvmOpcode.Aastore);
                        }
                    }
                }
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.NewObjectMethod);
                return null;
            }
            
            protected override Void handleSimpleName(SimpleNameExpressionNode simpleName, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = simpleName.getUserData(typeof(ExpressionInfo));
                var member = info.Member;
                switch (member.MemberKind) {
                case Local: {
                    var local = (LocalInfo)member;
                    if (context.MethodGenerationContext.TreeLocals.containsKey(local)) {
                        generator.emit(JvmOpcode.Aload, context.MethodGenerationContext.TreeLocals[local]);
                    } else {
                        BytecodeHelper.emitTypeof(generator, context.TypeSystem, local.Type);
                        if (local.IsUsedFromLambda) {
                            BytecodeGenerator.emitLoadLambdaScope(context, generator, local.Method);
                            generator.emit(JvmOpcode.Getfield, BytecodeGenerator.getLambdaScopeField(context, local));
                        } else {
                            generator.emit(BytecodeHelper.getLoadOpcode(local.Type), generator.getLocal(local.Name));
                        }
                        BytecodeGenerator.emitBoxing(context, simpleName);
                        if (local.Type.IsPrimitive) {
                            generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(local.Type));
                        }
                        generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
                    }
                    break;
                }
                case Field: {
                    var field = member.Field;
                    if (!field.IsStatic) {
                        statementGenerator.emitThisAccess(context, generator);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, field.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, field.Name);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredFieldMethod);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.FieldMethod);
                    break;
                }
                case Method: {
                    if (info.Method != null) {
                        emitDelegateCreation(info.Type, info.Method, simpleName, nested);
                    } else {
                        statementGenerator.emitThisAccess(context, generator);
                    }
                    break;
                }
                case Property: {
                    var method = member.GetAccessor;
                    if (!method.IsStatic) {
                        statementGenerator.emitThisAccess(context, generator);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                    break;
                }
                default:
                    throw new Exception("Internal error: unhandled name kind: " + member.MemberKind);
                }
                return null;
            }

            protected override Void handleSizeof(SizeofExpressionNode sizeofExpression, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, JvmTypeInfo.INT);
                generator.emit(JvmOpcode.Getstatic, statementGenerator.UnaryOperatorType.getField("Sizeof"));
                handleExpression(sizeofExpression.Expression, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.UnaryMethod);
                return null;
            }

            protected override Void handleThisAccess(ThisAccessExpressionNode thisAccess, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                statementGenerator.emitThisAccess(context, generator);
                return null;
            }
            
            protected override Void handleTypeof(TypeofExpressionNode typeofExpression, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, context.TypeSystem.ClassType);
                var type = typeofExpression.getUserData(typeof(JvmTypeInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, type);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
                return null;
            }
            
            protected override Void handleUnary(UnaryExpressionNode unary, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = unary.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                generator.emit(JvmOpcode.Getstatic, statementGenerator.UnaryOperatorType.getField(unary.Operator.toString()));
                handleExpression(unary.Operand, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.UnaryMethod);
                return null;
            }
                
            void emitNull() {
                var generator = context.MethodGenerationContext.Generator;
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
            }
        
            void emitArguments(List<ExpressionNode> arguments, Iterable<JvmParameterInfo> parameters, int nparams, boolean varargs) {
                int fixedLength = (varargs) ?  nparams - 1 : nparams;
                var generator = context.MethodGenerationContext.Generator;
                var it1 = parameters.iterator();
                var it2 = arguments.iterator();
                int i;
                for (i = 0; i < fixedLength; i++) {
                    it1.next();
                    var e = it2.next();
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i);
                    handleExpression(e, null, true);
                    generator.emit(JvmOpcode.Aastore);
                }
                if (varargs) {
                    int nvarargs = arguments.size() - fixedLength;
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i);
                    if (nvarargs == 1) {
                        var paramType = it1.next().Type;
                        var e = arguments[i];
                        var ei = e.getUserData(typeof(ExpressionInfo));
                        if (ei == null) {
                            emitNull();
                        } else if (ei.Type.IsArray && paramType.isAssignableFrom(ei.Type)) {
                            handleExpression(e, null, true);
                        } else {
                            BytecodeHelper.emitIntConstant(generator, 1);
                            statementGenerator.emitArray(1, paramType, it2);
                        }
                    } else {
                        BytecodeHelper.emitIntConstant(generator, nvarargs);
                        statementGenerator.emitArray(1, it1.next().Type, it2);
                    }
                    generator.emit(JvmOpcode.Aastore);
                }
            }
            
            void emitDelegateCreation(JvmTypeInfo delegateType, JvmMethodInfo method, ExpressionNode argument, boolean nested) {
                if (argument != null) {
                    var argType = argument.getUserData(typeof(ExpressionInfo)).Type;
                    if (argType != null && BytecodeHelper.isDelegateType(argType)) {
                        handleExpression(argument, null, nested);
                        return;
                    }
                }
                
                var generator = context.MethodGenerationContext.Generator;
                var typeInfo = CompilerHelper.createDelegateType(context, delegateType, method);
                var constructor = typeInfo.Methods.where(p => p.Name.equals("<init>")).first();
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, typeInfo);
                BytecodeHelper.emitIntConstant(generator, constructor.Parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                if (!method.IsStatic) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, constructor.Parameters.first().Type);
                    generator.emit(JvmOpcode.Aastore);
                }
                generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredConstructorMethod);
                BytecodeHelper.emitIntConstant(generator, (method.IsStatic) ? 0 : 1);
                BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                if (!method.IsStatic) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    handleExpression(argument, null, true);
                    generator.emit(JvmOpcode.Aastore);
                }
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.NewObjectMethod);
            }
        }
    }
}
