/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.lang;
using java.util;
using stab.query;
using stab.tools.bytecode;
using stab.tools.syntaxtree;
 
package stab.tools.compiler {

    class ExpressionTreeGenerator : StatementHandler<Void, Void> {
        private CompilerContext context;
        private ExpressionGenerator expressionGenerator;
    
        ExpressionTreeGenerator(CompilerContext context)
            : super(true) {
            this.context = context;
            this.expressionGenerator = new ExpressionGenerator(this, context);
        }
        
        void generateExpressionTree(LambdaExpressionNode lambda) {
            expressionGenerator.handleExpression(lambda, null, false);
        }
        
        protected override Void handleExpression(ExpressionStatementNode expression, Void source) {
            var info = expression.getUserData(typeof(StatementInfo));
            if (info == null) {
                return null;
            }
            var generator = context.MethodGenerationContext.Generator;
            var statementType = context.TypeSystem.getType("stab/tree/Statement");
            var expressionType = context.TypeSystem.getType("stab/tree/Expression");
            var expressionMethod = statementType.getMethod("expression", Collections.singletonList(expressionType));
            expressionGenerator.handleExpression(expression.Expression, null, true);
            generator.emit(JvmOpcode.Invokestatic, expressionMethod);
            return null;
        }
        
        static void emitThisAccess(CompilerContext context, JvmCodeGenerator generator) {
            BytecodeHelper.emitTypeof(generator, context.TypeSystem, context.MethodGenerationContext.CurrentMethod.DeclaringType);
            BytecodeGenerator.emitThisAccess(context, generator);
            var expressionType = context.TypeSystem.getType("stab/tree/Expression");
            var unboundedClassType = context.TypeSystem.getType("java/lang/Class").getGenericType(
                    Collections.singletonList(JvmTypeInfo.UNBOUNDED_WILDCARD));
            var valueParameters = new ArrayList<JvmTypeInfo> { unboundedClassType, context.TypeSystem.ObjectType };
            var valueMethod = expressionType.getMethod("value", valueParameters);
            generator.emit(JvmOpcode.Invokestatic, valueMethod);
        }
        
        void emitArray(int dimensions, JvmTypeInfo type, Iterator<ExpressionNode> values) {
            var generator = context.MethodGenerationContext.Generator;
            BytecodeHelper.emitNewarray(generator, dimensions, type.ElementType);
            if (values != null) {
                var opcode = BytecodeHelper.getAstoreOpcode(type.ElementType);
                int i = 0;
                while (values.hasNext()) {
                    var e = values.next();
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    expressionGenerator.handleExpression(e, null, true);
                    generator.emit(opcode);
                }
            }
        }
        
        private class ExpressionGenerator : ExpressionHandler<Void, Void> {
            private ExpressionTreeGenerator statementGenerator;
            private CompilerContext context;
        
            ExpressionGenerator(ExpressionTreeGenerator statementGenerator, CompilerContext context)
                : super(true) {
                this.statementGenerator = statementGenerator;
                this.context = context;
            }
            
            public override Void handleExpression(ExpressionNode expression, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = expression.getUserData(typeof(ExpressionInfo));
                var expressionType = context.TypeSystem.getType("stab/tree/Expression");
                var unboundedClassType = context.TypeSystem.getType("java/lang/Class").getGenericType(
                        Collections.singletonList(JvmTypeInfo.UNBOUNDED_WILDCARD));
                var valueParameters = new ArrayList<JvmTypeInfo> { unboundedClassType, context.TypeSystem.ObjectType };
                var valueMethod = expressionType.getMethod("value", valueParameters);
                if (info == null) {
                    emitNull();
                    return null;
                }
                if (!info.IsConstant) {
                    return super.handleExpression(expression, null, nested);
                }
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                var value = info.Value;
                switch (info.Type.TypeKind) {
                case Boolean:
                    if (((Boolean)value).booleanValue()) {
                        generator.emit(JvmOpcode.Iconst_1);
                    } else {
                        generator.emit(JvmOpcode.Iconst_0);
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;
                case Char:
                case Byte:
                case Short:
                case Int:
                    if (value instanceof Integer) {
                        BytecodeHelper.emitIntConstant(generator, ((Integer)value).intValue());
                    } else if (value instanceof Character) {
                        BytecodeHelper.emitIntConstant(generator, ((Character)value).charValue());
                    } else if (value instanceof Byte) {
                        BytecodeHelper.emitIntConstant(generator, ((Byte)value).byteValue());
                    } else if (value instanceof Short) {
                        BytecodeHelper.emitIntConstant(generator, ((Short)value).shortValue());
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Long:
                    long l = 0;
                    if (value instanceof Long) {
                        l = ((Long)value).longValue();
                    } else if (value instanceof Integer) {
                        l = ((Integer)value).intValue();
                    } else if (value instanceof Character) {
                        l = ((Character)value).charValue();
                    } else if (value instanceof Byte) {
                        l = ((Byte)value).byteValue();
                    } else if (value instanceof Short) {
                        l = ((Short)value).shortValue();
                    }
                    if (l == 0) {
                        generator.emit(JvmOpcode.Lconst_0);
                    } else if (l == 1) {
                        generator.emit(JvmOpcode.Lconst_1);
                    } else {
                        generator.emit(JvmOpcode.Ldc, Long.valueOf(l));
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Float:
                    float f = 0;
                    if (value instanceof Float) {
                        f = ((Float)value).floatValue();
                    } else if (value instanceof Long) {
                        f = ((Long)value).longValue();
                    } else if (value instanceof Integer) {
                        f = ((Integer)value).intValue();
                    } else if (value instanceof Character) {
                        f = ((Character)value).charValue();
                    } else if (value instanceof Byte) {
                        f = ((Byte)value).byteValue();
                    } else if (value instanceof Short) {
                        f = ((Short)value).shortValue();
                    }
                    if (f == 0f) {
                        generator.emit(JvmOpcode.Fconst_0);
                    } else if (f == 1f) {
                        generator.emit(JvmOpcode.Fconst_1);
                    } else if (f == 2f) {
                        generator.emit(JvmOpcode.Fconst_2);
                    } else {
                        generator.emit(JvmOpcode.Ldc, Float.valueOf(f));
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Double:
                    double d = 0;
                    if (value instanceof Double) {
                        d = ((Double)value).doubleValue();
                    } else if (value instanceof Float) {
                        d = ((Float)value).floatValue();
                    } else if (value instanceof Long) {
                        d = ((Long)value).longValue();
                    } else if (value instanceof Integer) {
                        d = ((Integer)value).intValue();
                    } else if (value instanceof Character) {
                        d = ((Character)value).charValue();
                    } else if (value instanceof Byte) {
                        d = ((Byte)value).byteValue();
                    } else if (value instanceof Short) {
                        d = ((Short)value).shortValue();
                    }
                    if (d == 0d) {
                        generator.emit(JvmOpcode.Dconst_0);
                    } else if (d == 1d) {
                        generator.emit(JvmOpcode.Dconst_1);
                    } else {
                        generator.emit(JvmOpcode.Ldc, Double.valueOf(d));
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                default:
                    generator.emit(JvmOpcode.Ldc, value);
                    break;
                }
                generator.emit(JvmOpcode.Invokestatic, valueMethod);
                return null;
            }
            
            protected override Void handleInvocation(InvocationExpressionNode invocation, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = invocation.getUserData(typeof(ExpressionInfo));
                var method = info.Method;
                if (method.IsExcludedFromCompilation || CompilerHelper.shouldIgnoreCalls(context, method)) {
                    return null;
                }
                var isDelegateInvocation = BytecodeHelper.isDelegateType(method.DeclaringType) && method.Name.equals("invoke");
                JvmMethodInfo getMethodMethod = null;
                if (!isDelegateInvocation) {
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    var classType = context.TypeSystem.getType("java/lang/Class");
                    getMethodMethod = classType.Methods.where(p => p.Name.equals("getDeclaredMethod")).single();
                    
                    BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                    BytecodeHelper.emitNewarray(generator, 1, classType);
                    int i = 0;
                    foreach (var p in method.Parameters) {
                        generator.emit(JvmOpcode.Dup);
                        BytecodeHelper.emitIntConstant(generator, i++);
                        BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                        generator.emit(JvmOpcode.Aastore);
                    }
                    generator.emit(JvmOpcode.Invokevirtual, getMethodMethod);
                }
                if (!method.IsStatic) {
                    if (isDelegateInvocation) {
                        handleExpression(invocation.TargetObject, null, true);
                    } else if (invocation.TargetObject.ExpressionKind == ExpressionKind.MemberAccess) {
                        var targetTarget = ((MemberAccessExpressionNode)invocation.TargetObject).TargetObject;
                        handleExpression(targetTarget, null, true);
                    } else { // SimpleName
                        ExpressionTreeGenerator.emitThisAccess(context, generator);
                    }
                } else {
                    emitNull();
                }
                var expressionType = context.TypeSystem.getType("stab/tree/Expression");
                BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, expressionType);
                
                int nParams = method.Parameters.count();
                int len = (method.IsVarargs) ? nParams - 1 : nParams;
                var arguments = invocation.Arguments;
                if (info.IsExtension) {
                    var target = (MemberAccessExpressionNode)invocation.TargetObject;
                    arguments = new ArrayList<ExpressionNode> { target.TargetObject };
                    arguments.addAll(invocation.Arguments);
                }
                emitArguments(arguments, method.Parameters, len, arguments.size() - len, method.IsVarargs);
                if (!isDelegateInvocation) {
                    var callParameters = new ArrayList<JvmTypeInfo> { getMethodMethod.ReturnType, expressionType, expressionType.ArrayType };
                    var callMethod = expressionType.getMethod("call", callParameters);
                    generator.emit(JvmOpcode.Invokestatic, callMethod);
                } else {
                    var invokeParameters = new ArrayList<JvmTypeInfo> { expressionType, expressionType.ArrayType };
                    var invokeMethod = expressionType.getMethod("invoke", invokeParameters);
                    generator.emit(JvmOpcode.Invokestatic, invokeMethod);
                }
                return null;
            }

            private void emitArguments(List<ExpressionNode> arguments, Iterable<JvmParameterInfo> parameters, int fixedLength,
                    int nvarargs, boolean varargs) {
                var generator = context.MethodGenerationContext.Generator;
                var it1 = parameters.iterator();
                var it2 = arguments.iterator();
                int i;
                for (i = 0; i < fixedLength; i++) {
                    var p = it1.next();
                    var e = it2.next();
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i);
                    handleExpression(e, null, true);
                    generator.emit(JvmOpcode.Aastore);
                }
                if (varargs) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i);
                    if (nvarargs > 0) {
                        var paramType = it1.next().Type;
                        if (nvarargs == 1) {
                            var e = arguments[i];
                            var ei = e.getUserData(typeof(ExpressionInfo));
                            if (ei == null) {
                                emitNull();
                            } else if (ei.Type.IsArray && paramType.isAssignableFrom(ei.Type)) {
                                handleExpression(e, null, true);
                            } else {
                                BytecodeHelper.emitIntConstant(generator, 1);
                                statementGenerator.emitArray(1, paramType, it2);
                            }
                        } else {
                            BytecodeHelper.emitIntConstant(generator, nvarargs);
                            statementGenerator.emitArray(1, paramType, it2);
                        }
                    } else {
                        BytecodeHelper.emitIntConstant(generator, 0);
                        statementGenerator.emitArray(1, it1.next().Type, it2);
                    }
                    generator.emit(JvmOpcode.Aastore);
                }
            }
            
            void emitNull() {
                var generator = context.MethodGenerationContext.Generator;
                var expressionType = context.TypeSystem.getType("stab/tree/Expression");
                var unboundedClassType = context.TypeSystem.getType("java/lang/Class").getGenericType(
                        Collections.singletonList(JvmTypeInfo.UNBOUNDED_WILDCARD));
                var valueParameters = new ArrayList<JvmTypeInfo> { unboundedClassType, context.TypeSystem.ObjectType };
                var valueMethod = expressionType.getMethod("value", valueParameters);
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Invokestatic, valueMethod);
            }
            
            protected override Void handleLambda(LambdaExpressionNode lambda, Void source, boolean nested) {
                var methodBuilder = lambda.getUserData(typeof(JvmMethodBuilder));
                ((JvmTypeBuilder)methodBuilder.DeclaringType).undefineMethod(methodBuilder);
                
                var info = lambda.getUserData(typeof(ExpressionInfo));
                
                var generator = context.MethodGenerationContext.Generator;
                generator.beginScope();
                var parameterExpressionType = context.TypeSystem.getType("stab/tree/ParameterExpression");
                var expressionType = context.TypeSystem.getType("stab/tree/Expression");
                var unboundedClassType = context.TypeSystem.getType("java/lang/Class").getGenericType(
                        Collections.singletonList(JvmTypeInfo.UNBOUNDED_WILDCARD));
                var parameterParameters = new ArrayList<JvmTypeInfo> { unboundedClassType, context.TypeSystem.StringType };
                var parameterMethod = expressionType.getMethod("parameter", parameterParameters);
                var parameters = new ArrayList<JvmLocalInfo>();
                foreach (var pi in methodBuilder.Parameters) {
                    var local = generator.declareLocal(parameterExpressionType, "tree$local" + context.MethodGenerationContext.nextGeneratedLocal());
                    parameters.add(local);
                    context.MethodGenerationContext.TreeLocals[pi.getUserData(typeof(LocalInfo))] = local;
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, pi.Type);
                    generator.emit(JvmOpcode.Ldc, pi.Name);
                    generator.emit(JvmOpcode.Invokestatic, parameterMethod);
                    generator.emit(JvmOpcode.Astore, local);
                }
                var treeMethod = expressionType.Methods.where(p => p.Name.equals("tree")).single();
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type.GenericArguments.single());
                
                BytecodeHelper.emitIntConstant(generator, parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, parameterExpressionType);
                int i = 0;
                foreach (var p in parameters) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    generator.emit(JvmOpcode.Aload, p);
                    generator.emit(JvmOpcode.Aastore);
                }
                
                statementGenerator.handleStatement(lambda.Body, null);
                generator.emit(JvmOpcode.Invokestatic, treeMethod);
                generator.endScope();
                return null;
            }
            
            protected override Void handleSimpleName(SimpleNameExpressionNode simpleName, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = simpleName.getUserData(typeof(ExpressionInfo));
                var member = info.Member;
                switch (member.MemberKind) {
                case Local: {
                    var local = (LocalInfo)member;
                    if (context.MethodGenerationContext.TreeLocals.containsKey(local)) {
                        generator.emit(JvmOpcode.Aload, context.MethodGenerationContext.TreeLocals[local]);
                    } else {
                        BytecodeHelper.emitTypeof(generator, context.TypeSystem, local.Type);
                        var expressionType = context.TypeSystem.getType("stab/tree/Expression");
                        var unboundedClassType = context.TypeSystem.getType("java/lang/Class").getGenericType(
                                Collections.singletonList(JvmTypeInfo.UNBOUNDED_WILDCARD));
                        var valueParameters = new ArrayList<JvmTypeInfo> { unboundedClassType, context.TypeSystem.ObjectType };
                        var valueMethod = expressionType.getMethod("value", valueParameters);
                        if (local.IsUsedFromLambda) {
                            BytecodeGenerator.emitLoadLambdaScope(context, generator, local.Method);
                            generator.emit(JvmOpcode.Getfield, BytecodeGenerator.getLambdaScopeField(context, local));
                        } else {
                            generator.emit(BytecodeHelper.getLoadOpcode(local.Type), generator.getLocal(local.Name));
                        }
                        BytecodeGenerator.emitBoxing(context, simpleName);
                        if (local.Type.IsPrimitive) {
                            generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(local.Type));
                        }
                        generator.emit(JvmOpcode.Invokestatic, valueMethod);
                    }
                    break;
                }
                case Field: {
                    var field = member.Field;
                    if (!field.IsStatic) {
                        ExpressionTreeGenerator.emitThisAccess(context, generator);
                    } else {
                        emitNull();
                    }
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, field.DeclaringType);
                    var classType = context.TypeSystem.getType("java/lang/Class");
                    var getFieldMethod = classType.getMethod("getDeclaredField", Collections.singletonList(context.TypeSystem.StringType));
                    generator.emit(JvmOpcode.Ldc, field.Name);
                    generator.emit(JvmOpcode.Invokevirtual, getFieldMethod);
                    var expressionType = context.TypeSystem.getType("stab/tree/Expression");
                    var fieldParameters = new ArrayList<JvmTypeInfo> { expressionType, context.TypeSystem.getType("java/lang/reflect/Field") };
                    var fieldMethod = expressionType.getMethod("field", fieldParameters);
                    generator.emit(JvmOpcode.Invokestatic, fieldMethod);
                    break;
                }
                default:
                    throw new Exception("Internal error: unhandled name kind: " + member.MemberKind);
                }
                return null;
            }
        }
    }
}
