/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.lang;
using java.util;
using stab.query;
using stab.tools.bytecode;
using stab.tools.syntaxtree;
 
package stab.tools.compiler {

    class ExpressionTreeGenerator : StatementHandler<Void, Void> {
        private CompilerContext context;
        private ExpressionGenerator expressionGenerator;
        private JvmTypeInfo expressionType;
        private JvmTypeInfo statementType;
        private JvmTypeInfo binaryOperatorType;
        private JvmTypeInfo unaryOperatorType;
        private JvmMethodInfo expressionMethod;
        private JvmMethodInfo valueMethod;
        private JvmMethodInfo getDeclaredMethodMethod;
        private JvmMethodInfo getDeclaredFieldMethod;
        private JvmMethodInfo callMethod;
        private JvmMethodInfo invokeMethod;
        private JvmMethodInfo parameterMethod;
        private JvmMethodInfo lambdaMethod;
        private JvmMethodInfo treeMethod;
        private JvmMethodInfo fieldMethod;
        private JvmMethodInfo binaryMethod;
        private JvmMethodInfo unaryMethod;
    
        ExpressionTreeGenerator(CompilerContext context)
            : super(true) {
            this.context = context;
            this.expressionGenerator = new ExpressionGenerator(this, context);
        }
        
        #region Reflection cache
        
        JvmTypeInfo ExpressionType {
            get {
                if (expressionType == null) {
                    expressionType = context.TypeSystem.getType("stab/tree/Expression");
                }
                return expressionType;
            }
        }
        
        JvmTypeInfo StatementType {
            get {
                if (statementType == null) {
                    statementType = context.TypeSystem.getType("stab/tree/Statement");
                }
                return statementType;
            }
        }
        
        JvmTypeInfo UnaryOperatorType {
            get {
                if (unaryOperatorType == null) {
                    unaryOperatorType = context.TypeSystem.getType("stab/tree/UnaryOperator");
                }
                return unaryOperatorType;
            }
        }
        
        JvmTypeInfo BinaryOperatorType {
            get {
                if (binaryOperatorType == null) {
                    binaryOperatorType = context.TypeSystem.getType("stab/tree/BinaryOperator");
                }
                return binaryOperatorType;
            }
        }
        
        JvmMethodInfo ExpressionMethod {
            get {
                if (expressionMethod == null) {
                    expressionMethod = this.StatementType.getMethod("expression", Query.singleton(this.ExpressionType));
                }
                return expressionMethod;
            }
        }

        JvmMethodInfo ValueMethod {
            get {
                if (valueMethod == null) {
                    var parameters = Query.pair(context.TypeSystem.UnboundedClassType, context.TypeSystem.ObjectType);
                    valueMethod = this.ExpressionType.getMethod("value", parameters);
                }
                return valueMethod;
            }
        }
        
        JvmMethodInfo GetDeclaredMethodMethod {
            get {
                if (getDeclaredMethodMethod == null) {
                    getDeclaredMethodMethod = context.TypeSystem.ClassType.Methods.where(p => p.Name.equals("getDeclaredMethod")).single();
                }
                return getDeclaredMethodMethod;
            }
        }
        
        JvmMethodInfo GetDeclaredFieldMethod {
            get {
                if (getDeclaredFieldMethod == null) {
                    var parameters = Query.singleton(context.TypeSystem.StringType);
                    getDeclaredFieldMethod = context.TypeSystem.ClassType.getMethod("getDeclaredField", parameters);
                }
                return getDeclaredFieldMethod;
            }
        }

        JvmMethodInfo CallMethod {
            get {
                if (callMethod == null) {
                    var parameters = Query.triple(this.ExpressionType, this.GetDeclaredMethodMethod.ReturnType, this.ExpressionType.ArrayType);
                    callMethod = this.ExpressionType.getMethod("call", parameters);
                }
                return callMethod;
            }
        }
        
        JvmMethodInfo InvokeMethod {
            get {
                if (invokeMethod == null) {
                    var parameters = Query.pair(this.ExpressionType, this.ExpressionType.ArrayType);
                    invokeMethod = this.ExpressionType.getMethod("invoke", parameters);
                }
                return invokeMethod;
            }
        }
        
        JvmMethodInfo ParameterMethod {
            get {
                if (parameterMethod == null) {
                    var parameters = Query.pair(context.TypeSystem.UnboundedClassType, context.TypeSystem.StringType);
                    parameterMethod = this.ExpressionType.getMethod("parameter", parameters);
                }
                return parameterMethod;
            }
        }

        JvmMethodInfo LambdaMethod {
            get {
                if (lambdaMethod == null) {
                    lambdaMethod = this.ExpressionType.Methods.where(p => p.Name.equals("lambda")).single();
                }
                return lambdaMethod;
            }
        }

        JvmMethodInfo TreeMethod {
            get {
                if (treeMethod == null) {
                    treeMethod = this.ExpressionType.Methods.where(p => p.Name.equals("tree")).single();
                }
                return treeMethod;
            }
        }

        JvmMethodInfo FieldMethod {
            get {
                if (fieldMethod == null) {
                    var parameters = Query.pair(this.ExpressionType, this.GetDeclaredFieldMethod.ReturnType);
                    fieldMethod = this.ExpressionType.getMethod("field", parameters);
                }
                return fieldMethod;
            }
        }
        
        JvmMethodInfo BinaryMethod {
            get {
                if (binaryMethod == null) {
                    var parameters = Query.quadruple(context.TypeSystem.UnboundedClassType,
                            this.ExpressionType, this.BinaryOperatorType, this.ExpressionType);
                    binaryMethod = this.ExpressionType.getMethod("binary", parameters);
                }
                return binaryMethod;
            }
        }
        
        JvmMethodInfo UnaryMethod {
            get {
                if (unaryMethod == null) {
                    var parameters = Query.triple(context.TypeSystem.UnboundedClassType, this.UnaryOperatorType, this.ExpressionType);
                    unaryMethod = this.ExpressionType.getMethod("unary", parameters);
                }
                return unaryMethod;
            }
        }
        
        #endregion
        
        void generateExpressionTree(LambdaExpressionNode lambda) {
            expressionGenerator.handleExpression(lambda, null, false);
        }
        
        protected override Void handleExpression(ExpressionStatementNode expression, Void source) {
            var info = expression.getUserData(typeof(StatementInfo));
            if (info == null) {
                return null;
            }
            var generator = context.MethodGenerationContext.Generator;
            expressionGenerator.handleExpression(expression.Expression, null, true);
            generator.emit(JvmOpcode.Invokestatic, this.ExpressionMethod);
            return null;
        }
        
        void emitThisAccess(CompilerContext context, JvmCodeGenerator generator) {
            BytecodeHelper.emitTypeof(generator, context.TypeSystem, context.MethodGenerationContext.CurrentMethod.DeclaringType);
            BytecodeGenerator.emitThisAccess(context, generator);
            generator.emit(JvmOpcode.Invokestatic, this.ValueMethod);
        }
        
        void emitArray(int dimensions, JvmTypeInfo type, Iterator<ExpressionNode> values) {
            var generator = context.MethodGenerationContext.Generator;
            BytecodeHelper.emitNewarray(generator, dimensions, type.ElementType);
            if (values != null) {
                var opcode = BytecodeHelper.getAstoreOpcode(type.ElementType);
                int i = 0;
                while (values.hasNext()) {
                    var e = values.next();
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    expressionGenerator.handleExpression(e, null, true);
                    generator.emit(opcode);
                }
            }
        }
        
        private class ExpressionGenerator : ExpressionHandler<Void, Void> {
            private ExpressionTreeGenerator statementGenerator;
            private CompilerContext context;
        
            ExpressionGenerator(ExpressionTreeGenerator statementGenerator, CompilerContext context)
                : super(true) {
                this.statementGenerator = statementGenerator;
                this.context = context;
            }
            
            public override Void handleExpression(ExpressionNode expression, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = expression.getUserData(typeof(ExpressionInfo));
                if (info == null) {
                    emitNull();
                    return null;
                }
                if (!info.IsConstant) {
                    return super.handleExpression(expression, null, nested);
                }
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                var value = info.Value;
                switch (info.Type.TypeKind) {
                case Boolean:
                    if (((Boolean)value).booleanValue()) {
                        generator.emit(JvmOpcode.Iconst_1);
                    } else {
                        generator.emit(JvmOpcode.Iconst_0);
                    }
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;
                case Char:
                case Byte:
                case Short:
                case Int:
                    BytecodeHelper.emitIntConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Long:
                    BytecodeHelper.emitLongConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Float:
                    BytecodeHelper.emitFloatConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                case Double:
                    BytecodeHelper.emitDoubleConstant(generator, value);
                    generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(info.Type));
                    break;

                default:
                    generator.emit(JvmOpcode.Ldc, value);
                    break;
                }
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
                return null;
            }
            
            protected override Void handleBinary(BinaryExpressionNode binary, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = binary.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                handleExpression(binary.LeftOperand, null, true);
                generator.emit(JvmOpcode.Getstatic, statementGenerator.BinaryOperatorType.getField(binary.Operator.toString()));
                handleExpression(binary.RightOperand, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.BinaryMethod);
                return null;
            }
            
            protected override Void handleInvocation(InvocationExpressionNode invocation, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = invocation.getUserData(typeof(ExpressionInfo));
                var method = info.Method;
                if (method.IsExcludedFromCompilation || CompilerHelper.shouldIgnoreCalls(context, method)) {
                    return null;
                }
                var isDelegateInvocation = BytecodeHelper.isDelegateType(method.DeclaringType) && method.Name.equals("invoke");
                if (!method.IsStatic) {
                    if (isDelegateInvocation) {
                        handleExpression(invocation.TargetObject, null, true);
                    } else if (invocation.TargetObject.ExpressionKind == ExpressionKind.MemberAccess) {
                        var targetTarget = ((MemberAccessExpressionNode)invocation.TargetObject).TargetObject;
                        handleExpression(targetTarget, null, true);
                    } else { // SimpleName
                        statementGenerator.emitThisAccess(context, generator);
                    }
                } else {
                    emitNull();
                }
                if (!isDelegateInvocation) {
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    
                    BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    int i = 0;
                    foreach (var p in method.Parameters) {
                        generator.emit(JvmOpcode.Dup);
                        BytecodeHelper.emitIntConstant(generator, i++);
                        BytecodeHelper.emitTypeof(generator, context.TypeSystem, p.Type);
                        generator.emit(JvmOpcode.Aastore);
                    }
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                }
                
                BytecodeHelper.emitIntConstant(generator, method.Parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                
                int nParams = method.Parameters.count();
                int len = (method.IsVarargs) ? nParams - 1 : nParams;
                var arguments = invocation.Arguments;
                if (info.IsExtension) {
                    var target = (MemberAccessExpressionNode)invocation.TargetObject;
                    arguments = new ArrayList<ExpressionNode> { target.TargetObject };
                    arguments.addAll(invocation.Arguments);
                }
                emitArguments(arguments, method.Parameters, len, arguments.size() - len, method.IsVarargs);
                if (!isDelegateInvocation) {
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                } else {
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.InvokeMethod);
                }
                return null;
            }

            private void emitArguments(List<ExpressionNode> arguments, Iterable<JvmParameterInfo> parameters, int fixedLength,
                    int nvarargs, boolean varargs) {
                var generator = context.MethodGenerationContext.Generator;
                var it1 = parameters.iterator();
                var it2 = arguments.iterator();
                int i;
                for (i = 0; i < fixedLength; i++) {
                    var p = it1.next();
                    var e = it2.next();
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i);
                    handleExpression(e, null, true);
                    generator.emit(JvmOpcode.Aastore);
                }
                if (varargs) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i);
                    if (nvarargs > 0) {
                        var paramType = it1.next().Type;
                        if (nvarargs == 1) {
                            var e = arguments[i];
                            var ei = e.getUserData(typeof(ExpressionInfo));
                            if (ei == null) {
                                emitNull();
                            } else if (ei.Type.IsArray && paramType.isAssignableFrom(ei.Type)) {
                                handleExpression(e, null, true);
                            } else {
                                BytecodeHelper.emitIntConstant(generator, 1);
                                statementGenerator.emitArray(1, paramType, it2);
                            }
                        } else {
                            BytecodeHelper.emitIntConstant(generator, nvarargs);
                            statementGenerator.emitArray(1, paramType, it2);
                        }
                    } else {
                        BytecodeHelper.emitIntConstant(generator, 0);
                        statementGenerator.emitArray(1, it1.next().Type, it2);
                    }
                    generator.emit(JvmOpcode.Aastore);
                }
            }
            
            void emitNull() {
                var generator = context.MethodGenerationContext.Generator;
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Aconst_Null);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
            }
            
            protected override Void handleLambda(LambdaExpressionNode lambda, Void source, boolean nested) {
                var methodBuilder = lambda.getUserData(typeof(JvmMethodBuilder));
                ((JvmTypeBuilder)methodBuilder.DeclaringType).undefineMethod(methodBuilder);
                
                var info = lambda.getUserData(typeof(ExpressionInfo));
                
                var generator = context.MethodGenerationContext.Generator;
                generator.beginScope();
                var parameterExpressionType = statementGenerator.ParameterMethod.ReturnType;
                var parameters = new ArrayList<JvmLocalInfo>();
                foreach (var pi in methodBuilder.Parameters) {
                    var local = generator.declareLocal(parameterExpressionType, "tree$local" + context.MethodGenerationContext.nextGeneratedLocal());
                    parameters.add(local);
                    context.MethodGenerationContext.TreeLocals[pi.getUserData(typeof(LocalInfo))] = local;
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, pi.Type);
                    generator.emit(JvmOpcode.Ldc, pi.Name);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.ParameterMethod);
                    generator.emit(JvmOpcode.Astore, local);
                }
                var method = (nested) ? statementGenerator.LambdaMethod : statementGenerator.TreeMethod;
                if (info.Type.FullName.equals("stab/tree/ExpressionTree")) {
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type.GenericArguments.single());
                } else {
                    BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                }
                BytecodeHelper.emitIntConstant(generator, parameters.count());
                BytecodeHelper.emitNewarray(generator, 1, parameterExpressionType);
                int i = 0;
                foreach (var p in parameters) {
                    generator.emit(JvmOpcode.Dup);
                    BytecodeHelper.emitIntConstant(generator, i++);
                    generator.emit(JvmOpcode.Aload, p);
                    generator.emit(JvmOpcode.Aastore);
                }
                
                statementGenerator.handleStatement(lambda.Body, null);
                generator.emit(JvmOpcode.Invokestatic, method);
                generator.endScope();
                return null;
            }
            
            protected override Void handleMemberAccess(MemberAccessExpressionNode memberAccess, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = memberAccess.getUserData(typeof(ExpressionInfo));
                if (info.Method != null) {
                    emitDelegateCreation(info.Type, info.Method, memberAccess);
                    return null;
                }
                var member = info.Member;
                if (member == null) {
                    handleExpression(memberAccess.TargetObject, null, true);
                    return null;
                }
                switch (member.MemberKind) {
                case Field: {
                    var field = member.Field;
                    if (!field.IsStatic) {
                        handleExpression(memberAccess.TargetObject, null, true);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, field.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, field.Name);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredFieldMethod);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.FieldMethod);
                    break;
                }
                case Property: {
                    var method = member.GetAccessor;
                    if (!method.IsStatic) {
                        handleExpression(memberAccess.TargetObject, null, true);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                    break;
                }
                default:
                    throw new Exception("Internal error: unhandled name kind: " + member.MemberKind);
                }
                return null;
            }
            
            protected override Void handleSimpleName(SimpleNameExpressionNode simpleName, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = simpleName.getUserData(typeof(ExpressionInfo));
                var member = info.Member;
                switch (member.MemberKind) {
                case Local: {
                    var local = (LocalInfo)member;
                    if (context.MethodGenerationContext.TreeLocals.containsKey(local)) {
                        generator.emit(JvmOpcode.Aload, context.MethodGenerationContext.TreeLocals[local]);
                    } else {
                        BytecodeHelper.emitTypeof(generator, context.TypeSystem, local.Type);
                        if (local.IsUsedFromLambda) {
                            BytecodeGenerator.emitLoadLambdaScope(context, generator, local.Method);
                            generator.emit(JvmOpcode.Getfield, BytecodeGenerator.getLambdaScopeField(context, local));
                        } else {
                            generator.emit(BytecodeHelper.getLoadOpcode(local.Type), generator.getLocal(local.Name));
                        }
                        BytecodeGenerator.emitBoxing(context, simpleName);
                        if (local.Type.IsPrimitive) {
                            generator.emit(JvmOpcode.Invokestatic, context.TypeSystem.getBoxingMethod(local.Type));
                        }
                        generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
                    }
                    break;
                }
                case Field: {
                    var field = member.Field;
                    if (!field.IsStatic) {
                        statementGenerator.emitThisAccess(context, generator);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, field.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, field.Name);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredFieldMethod);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.FieldMethod);
                    break;
                }
                case Method: {
                    if (info.Method != null) {
                        emitDelegateCreation(info.Type, info.Method, simpleName);
                    } else {
                        statementGenerator.emitThisAccess(context, generator);
                    }
                    break;
                }
                case Property: {
                    var method = member.GetAccessor;
                    if (!method.IsStatic) {
                        statementGenerator.emitThisAccess(context, generator);
                    } else {
                        emitNull();
                    }
                    generator.emit(JvmOpcode.Ldc, method.DeclaringType);
                    generator.emit(JvmOpcode.Ldc, method.Name);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, context.TypeSystem.ClassType);
                    generator.emit(JvmOpcode.Invokevirtual, statementGenerator.GetDeclaredMethodMethod);
                    BytecodeHelper.emitIntConstant(generator, 0);
                    BytecodeHelper.emitNewarray(generator, 1, statementGenerator.ExpressionType);
                    generator.emit(JvmOpcode.Invokestatic, statementGenerator.CallMethod);
                    break;
                }
                default:
                    throw new Exception("Internal error: unhandled name kind: " + member.MemberKind);
                }
                return null;
            }

            protected override Void handleThisAccess(ThisAccessExpressionNode thisAccess, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                statementGenerator.emitThisAccess(context, generator);
                return null;
            }
            
            private void emitDelegateCreation(JvmTypeInfo delegateType, JvmMethodInfo method, ExpressionNode argument) {
                throw new Exception("TODO");
            }
            
            protected override Void handleTypeof(TypeofExpressionNode typeofExpression, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, context.TypeSystem.ClassType);
                var type = typeofExpression.getUserData(typeof(JvmTypeInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, type);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.ValueMethod);
                return null;
            }
            
            protected override Void handleUnary(UnaryExpressionNode unary, Void source, boolean nested) {
                var generator = context.MethodGenerationContext.Generator;
                var info = unary.getUserData(typeof(ExpressionInfo));
                BytecodeHelper.emitTypeof(generator, context.TypeSystem, info.Type);
                generator.emit(JvmOpcode.Getstatic, statementGenerator.UnaryOperatorType.getField(unary.Operator.toString()));
                handleExpression(unary.Operand, null, true);
                generator.emit(JvmOpcode.Invokestatic, statementGenerator.UnaryMethod);
                return null;
            }
        }
    }
}
