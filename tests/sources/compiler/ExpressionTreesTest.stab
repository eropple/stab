/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.io;
using java.lang;
using java.util;
using org.junit;
using stab.query;
using stab.tools.helpers;
using stab.tree;

package stab.tools.compiler.test {

	public class ExpressionTreesTest {
		[Test]
		public void value() {
			ExpressionTree<FunctionInt> tree = () => 1;
			doTest("value", tree);
		}

		[Test]
		public void variable() {
			ExpressionTree<FunctionIntInt> tree = p => p;
			doTest("variable", tree);
		}

		[Test]
		public void unary() {
			ExpressionTree<FunctionIntInt> tree = p => -p;
			doTest("unary", tree);
		}

		[Test]
		public void cast() {
			ExpressionTree<FunctionDoubleInt> tree = p => (int)p;
			doTest("cast", tree);
		}

		[Test]
		public void binary() {
			ExpressionTree<FunctionIntInt> tree = p => p + 1;
			doTest("binary", tree);
		}

		int testField;
		
		[Test]
		public void field() {
			ExpressionTree<FunctionInt> tree = () => testField;
			doTest("field", tree);
		}
		
		private void doTest(String test, LambdaExpression lambda) {
			variables = new ArrayList<VariableExpression>();
			var result = lambdaToString(lambda);
			
			var userDir = System.getProperty("user.dir");
			var generatedPath = PathHelper.combine(userDir, "tests/resources/ExpressionTreesTest/generated");
			var generatedDir = new File(generatedPath);
			if (!generatedDir.exists()) {
				generatedDir.mkdir();
			}
			var fileWriter = new FileWriter(PathHelper.combine(generatedPath, test + ".txt"));
			fileWriter.write(result);
			fileWriter.close();
		
			var referencePath = PathHelper.combine(PathHelper.combine(userDir, "tests/resources/ExpressionTreesTest/references"), test + ".txt");
			var referenceFile = new File(referencePath);
			String reference = null;
			if (referenceFile.exists()) {
				var fileReader = new FileReader(referencePath);
				reference = readToEnd(fileReader);
			} else {
				Assert.fail("No reference for '" + test + "'");
			}
			
			if (reference != null) {
				var genReader = new BufferedReader(new StringReader(result));
				var refReader = new BufferedReader(new StringReader(reference));
				for (;;) {
					var genLine = genReader.readLine();
					var refLine = refReader.readLine();
					if (genLine == null && refLine == null) {
						break;
					}
					Assert.assertEquals(refLine, genLine);
				}
			}
		}
		
		private String lambdaToString(LambdaExpression lambda) {
			var sb = new StringBuilder();
			sb.append("stab.tree.ExpressionTree<");
			sb.append(lambda.Type);
			sb.append("> tree =\n\t(");
			var first = true;
			foreach (var p in lambda.Parameters) {
				if (first) {
					first = false;
				} else {
					sb.append(", ");
				}
				variableToString(p, sb);
			}
			sb.append(") =>\n");
			statementToString(lambda.Body, sb, "    ");
			return sb.toString();
		}
		
		private void statementToString(Statement statement, StringBuilder sb, String indent) {
			switch (statement.StatementKind) {
			case Expression:
				var expression = (ExpressionStatement)statement;
				expressionToString(expression.Expression, sb, indent);
				sb.append(";");
				break;
				
			default:
				throw new IllegalStateException("Unhandled statement " + statement.StatementKind);
			}
			sb.append("\n");
		}
		
		private void expressionToString(Expression expression, StringBuilder sb, String indent) {
			switch (expression.ExpressionKind) {
			case Binary:
				sb.append(indent);
				binaryToString((BinaryExpression)expression, sb);
				break;
				
			case Field:
				sb.append(indent);
				fieldToString((FieldExpression)expression, sb);
				break;
				
			case Parameter:
				sb.append(indent);
				variableToString((VariableExpression)expression, sb);
				break;

			case Unary:
				sb.append(indent);
				unaryToString((UnaryExpression)expression, sb);
				break;
				
			case Value:
				sb.append(indent);
				valueToString((ValueExpression)expression, sb);
				break;
				
			default:
				throw new IllegalStateException("Unhandled expression " + expression.ExpressionKind);
			}
		}
		
		private void binaryToString(BinaryExpression binary, StringBuilder sb) {
			expressionToString(binary.Left, sb, "");
			switch (binary.Operator) {
			case Add:
				sb.append(" + ");
				break;
			case AddAssign:
				sb.append(" += ");
				break;
			case And:
				sb.append(" & ");
				break;
			case AndAssign:
				sb.append(" &= ");
				break;
			case Assign:
				sb.append(" = ");
				break;
			case Divide:
				sb.append(" / ");
				break;
			case DivideAssign:
				sb.append(" /= ");
				break;
			case Element:
				sb.append("[");
				break;
			case Equal:
				sb.append("==");
				break;
			case GreaterThan:
				sb.append(" > ");
				break;
			case GreaterThanOrEqual:
				sb.append(" >= ");
				break;
			case LeftShift:
				sb.append(" << ");
				break;
			case LeftShiftAssign:
				sb.append(" <<= ");
				break;
			case LessThan:
				sb.append(" < ");
				break;
			case LessThanOrEqual:
				sb.append(" <= ");
				break;
			case LogicalAnd:
				sb.append(" && ");
				break;
			case LogicalOr:
				sb.append(" || ");
				break;
			case Modulo:
				sb.append(" % ");
				break;
			case ModuloAssign:
				sb.append(" %= ");
				break;
			case Multiply:
				sb.append(" * ");
				break;
			case MultiplyAssign:
				sb.append(" *= ");
				break;
			case NotEqual:
				sb.append(" != ");
				break;
			case NullCoalescing:
				sb.append(" ?? ");
				break;
			case Or:
				sb.append(" | ");
				break;
			case OrAssign:
				sb.append(" |= ");
				break;
			case RightShift:
				sb.append(" >> ");
				break;
			case RightShiftAssign:
				sb.append(" >>= ");
				break;
			case Subtract:
				sb.append(" - ");
				break;
			case SubtractAssign:
				sb.append(" -= ");
				break;
			case UnsignedRightShift:
				sb.append(" >>> ");
				break;
			case UnsignedRightShiftAssign:
				sb.append(" >>>= ");
				break;
			case Xor:
				sb.append(" ^ ");
				break;
			case XorAssign:
				sb.append(" ^= ");
				break;
			}
			expressionToString(binary.Right, sb, "");
			switch (binary.Operator) {
			case Element:
				sb.append("]");
				break;
			}
		}

		private void fieldToString(FieldExpression field, StringBuilder sb) {
			expressionToString(field.Target, sb, "");
			sb.append(".").append(field.Field.getName());
		}
		
		private void unaryToString(UnaryExpression unary, StringBuilder sb) {
			switch (unary.Operator) {
			case Cast:
				sb.append("(").append(unary.Type).append(")");
				break;
			case Complement:
				sb.append("~");
				break;
			case Minus:
				sb.append("-");
				break;
			case Not:
				sb.append("!");
				break;
			case Plus:
				sb.append("+");
				break;
			case PreDecrement:
				sb.append("--");
				break;
			case PreIncrement:
				sb.append("++");
				break;
			case Sizeof:
				sb.append("sizeof(");
				break;
			}
			expressionToString(unary.Operand, sb, "");
			switch (unary.Operator) {
			case As:
				sb.append(" as ").append(unary.Type);
				break;
			case PostDecrement:
				sb.append("--");
				break;
			case PostIncrement:
				sb.append("++");
				break;
			case Sizeof:
				sb.append(")");
				break;
			}
		}

		private void valueToString(ValueExpression value, StringBuilder sb) {
			sb.append("#Value#").append(value.Type).append("#").append((value.Value == this) ? "this" : value.Value).append("#");
		}
		
		private List<VariableExpression> variables;
	
		private void variableToString(VariableExpression variable, StringBuilder sb) {
			var n = variables.indexOf(variable);
			if (n == -1) {
				n = variables.size();
				variables.add(variable);
			}
			sb.append("#").append(variable.ExpressionKind).append(n).append("#").append(variable.Type).append("#").append(variable.Name).append("#");
		}
		
		private String readToEnd(Reader reader) {
			var sb = new StringBuilder();
			var buff = new char[1024];
			int read;
			while ((read = reader.read(buff)) != -1) {
				sb.append(buff, 0, read);
			}
			return sb.toString();
		}
	}
}
