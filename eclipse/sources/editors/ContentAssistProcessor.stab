/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.lang;
using java.util;
using org.eclipse.jface.text;
using org.eclipse.jface.text.contentassist;
using org.eclipse.jface.text.source;
using stab.query;
using stab.tools.bytecode;
using stab.tools.compiler;
using stab.tools.helpers;
using stab.tools.parser;
using stab.tools.syntaxtree;

package stab.tools.eclipse.editors {

	public class ContentAssistProcessor : IContentAssistProcessor {
		private static final ICompletionProposal[] EMPTY_PROPOSALS = CompletionProposalHelper.createEmpty();
		private static final Iterable<String> BODY_TEXTS = new ArrayList<String> {
			"boolean", "byte", "char", "do", "double", "float", "for", "foreach", "if", "int",
			"long", "new", "short", "synchronized", "using", "while" };
		private static final Iterable<String> TYPE_TEXTS = new ArrayList<String> {
			"boolean", "byte", "char", "double", "float", "int", "long", "short" };
	
		private SourceEditor editor;
		private ISourceViewer sourceViewer;
		
		private int offset;
		private int tokenIndex;
		private Token token;
		private char[] text;
		private List<Token> tokens;
		private ContentAssistContext context;
		private StatementProcessor statementProcessor;
		private ExpressionProcessor expressionProcessor;

		public ContentAssistProcessor(SourceEditor editor, ISourceViewer sourceViewer) {
			this.editor = editor;
			this.sourceViewer = sourceViewer;
			this.statementProcessor = new StatementProcessor(this);
			this.expressionProcessor = new ExpressionProcessor(this);
		}
		
		public IContextInformation[] computeContextInformation(ITextViewer viewer, int offset) {
			return null;
		}
		
		public char[] getContextInformationAutoActivationCharacters() {
			return null;
		}
	
		public String getErrorMessage() {
			return null;
		}
		
		public IContextInformationValidator getContextInformationValidator() {
			return null;
		}
		
		public char[] getCompletionProposalAutoActivationCharacters() {
			return null;
		}
		
		public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {
			Environment.trace(this, "compute completion");
			var t0 = System.nanoTime();

			var file = editor.getFile();
			if (file == null) {
				Environment.trace(this, "no file");
				return EMPTY_PROPOSALS;
			}
			
			var projectManager = Environment.getProjectManager(file);
			if (projectManager == null) {
				Environment.trace(this, "not a project with Stab nature");
				return EMPTY_PROPOSALS;
			}
			
			var highlighter = editor.Highlighter;
			if (highlighter == null) {
				Environment.trace(this, "no highlighter");
				return EMPTY_PROPOSALS;
			}
			
			var tokens = highlighter.Tokens;
			if (tokens == null || tokens.size() == 0) {
				Environment.trace(this, "no tokens");
				return EMPTY_PROPOSALS;
			}
			
			var tokenIndex = Highlighter.getPositionIndex(tokens, offset);
			if (tokenIndex == -1) {
				Environment.trace(this, "no token at " + offset);
				return EMPTY_PROPOSALS;
			}

			var token = tokens[tokenIndex];
			var beforeToken = token.offset == offset;

			Environment.trace(this, "token " + token.LexicalUnit);
			
			if (token.SemanticStyle != null && !beforeToken) {
				switch (token.SemanticStyle) {
				case Preprocessor:
				case SkippedSource:
					Environment.trace(this, "in preprocessor part");
					return EMPTY_PROPOSALS;
				case DelimitedComment:
				case SingleLineComment:
					Environment.trace(this, "in comment");
					return EMPTY_PROPOSALS;
				}
			}
			if (token.LexicalUnit == LexicalUnit.NewLine) {
				if (tokenIndex > 0 && tokens[tokenIndex - 1].LexicalUnit == LexicalUnit.SingleLineComment) {
					Environment.trace(this, "in comment");
					return EMPTY_PROPOSALS;
				}
			}

			var compilationUnit = highlighter.CompilationUnit;
			if (compilationUnit == null) {
				Environment.trace(this, "no AST");
				return EMPTY_PROPOSALS;
			}

			this.offset = offset;
			this.tokenIndex = tokenIndex;
			this.token = token;
			this.tokens = tokens;
			this.text = highlighter.Text;
			this.context = new ContentAssistContext(projectManager.TypeSystem);

			var result = computeCompletionProposalsInPackage(Query.empty<String>(), compilationUnit.Body);
			Environment.trace(this, "compute completion done in " + ((System.nanoTime() - t0) / 1e6) + "ms");
			return result;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInPackage(Iterable<String> names, PackageBodyNode body) {
			var beforeMembers = true;
			if (body != null) {
				foreach (var u in body.UsingDirectives) {
					var bounds = u.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(offset)) {
						break;
					}
					if (bounds.isBeforeOffset(offset)) {
						continue;
					}
		
					// TODO
					Environment.trace(this, "using");
					return EMPTY_PROPOSALS;
				}

				context.enterPackage(names, body);
				
				foreach (var m in body.Members) {
					var bounds = ((SyntaxNode)m).getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(offset)) {
						break;
					}
					beforeMembers = false;
					if (bounds.isBeforeOffset(offset)) {
						continue;
					}
					switch (m.PackageMemberKind) {
					case Package:
						var pkg = (PackageDeclarationNode)m;
						return computeCompletionProposalsInPackage(pkg.Identifiers.select(p => p.getUserData(typeof(String))), pkg.Body);
					case Class:
						return computeCompletionProposalsInClass((ClassDeclarationNode)m);
					case Interface:
						return computeCompletionProposalsInInterface((InterfaceDeclarationNode)m);
					case Delegate:
						return computeCompletionProposalsInDelegate((DelegateDeclarationNode)m);
					}
				}
				if (beforeMembers) {
				}
			}
			
			// TODO
			Environment.trace(this, "package " + beforeMembers);
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInClass(ClassDeclarationNode declaration) {
			var beforeMembers = true;
			foreach (var m in declaration.Members) {
				var bounds = ((SyntaxNode)m).getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				beforeMembers = false;
				if (bounds.isBeforeOffset(offset)) {
					continue;
				}
				context.enterClass(declaration);
				switch (m.TypeMemberKind) {
				case Class:
					return computeCompletionProposalsInClass((ClassDeclarationNode)m);
				case Interface:
					return computeCompletionProposalsInInterface((InterfaceDeclarationNode)m);
				case Delegate:
					return computeCompletionProposalsInDelegate((DelegateDeclarationNode)m);
				case Method:
					return computeCompletionProposalsInMethod((MethodDeclarationNode)m);
				case Property:
					return computeCompletionProposalsInProperty((PropertyDeclarationNode)m);
				case Indexer:
					return computeCompletionProposalsInIndexer((IndexerDeclarationNode)m);
				case Constructor:
					return computeCompletionProposalsInConstructor((ConstructorDeclarationNode)m);
				case Destructor:
					return computeCompletionProposalsInDestructor((DestructorDeclarationNode)m);
				case Field:
					return computeCompletionProposalsInField((FieldDeclarationNode)m);
				case EnumConstant:
					return computeCompletionProposalsInEnumConstant((EnumConstantDeclarationNode)m);
				}
			}
			
			// TODO
			Environment.trace(this, "class " + beforeMembers);
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInInterface(InterfaceDeclarationNode declaration) {
			var beforeMembers = true;
			foreach (var m in declaration.Members) {
				var bounds = ((SyntaxNode)m).getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				beforeMembers = false;
				if (bounds.isBeforeOffset(offset)) {
					continue;
				}
				context.enterInterface(declaration);
				switch (m.TypeMemberKind) {
				case Method:
					return computeCompletionProposalsInMethod((MethodDeclarationNode)m);
				case Property:
					return computeCompletionProposalsInProperty((PropertyDeclarationNode)m);
				case Indexer:
					return computeCompletionProposalsInIndexer((IndexerDeclarationNode)m);
				}
			}
				
			// TODO
			Environment.trace(this, "interface " + beforeMembers);
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInDelegate(DelegateDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "delegate");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInMethod(MethodDeclarationNode declaration) {
			var m = declaration.getUserData(typeof(JvmMethodInfo));
			if (containsOffset(declaration.ReturnType)) {
				return computeCompletionProposalsInType(declaration.ReturnType, m.ReturnType);
			}
			var pit = m.Parameters.iterator();
			foreach (var p in declaration.Parameters) {
				var pt = pit.next().Type;
			
				var bounds = p.getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				if (bounds.isBeforeOffset(offset)) {
					continue;
				}
			
				if (containsOffset(p.Type)) {
					return computeCompletionProposalsInType(p.Type, pt);
				}
	
				Environment.trace(this, "method parameter");
				return EMPTY_PROPOSALS;
			}
			var body = declaration.Body;
			if (body != null && containsOffset(body)) {
				context.enterMethod(declaration);
				return statementProcessor.handleStatement(body, null);
			}
		
			// TODO
			Environment.trace(this, "method");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInProperty(PropertyDeclarationNode declaration) {
			var get = declaration.GetAccessor;
			var set = declaration.SetAccessor;
			JvmTypeInfo t = null;
			if (get != null) {
				var m = get.getUserData(typeof(JvmMethodInfo));
				t = m.ReturnType;
			} else if (set != null) {
				var m = set.getUserData(typeof(JvmMethodInfo));
				t = m.Parameters.first().Type;
			}
			
			if (containsOffset(declaration.Type)) {
				return computeCompletionProposalsInType(declaration.Type, t);
			}
			if (get != null && containsOffset(get)) {
				var body = get.Body;
				if (body != null && containsOffset(body)) {
					context.enterPropertyGetter(declaration);
					return statementProcessor.handleStatement(body, null);
				}
		
				// TODO
				Environment.trace(this, "property getter");
				return EMPTY_PROPOSALS;
			}
			if (set != null && containsOffset(set)) {
				var body = set.Body;
				if (body != null && containsOffset(body)) {
					context.enterPropertySetter(declaration);
					return statementProcessor.handleStatement(body, null);
				}
		
				// TODO
				Environment.trace(this, "property setter");
				return EMPTY_PROPOSALS;
			}
			
			// TODO
			Environment.trace(this, "property");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInIndexer(IndexerDeclarationNode declaration) {
			var get = declaration.GetAccessor;
			var set = declaration.SetAccessor;
			JvmTypeInfo t = null;
			JvmMethodInfo m = null;
			if (get != null) {
				m = get.getUserData(typeof(JvmMethodInfo));
				t = m.ReturnType;
			} else if (set != null) {
				m = set.getUserData(typeof(JvmMethodInfo));
				t = m.Parameters.last().Type;
			}
			
			if (containsOffset(declaration.Type)) {
				return computeCompletionProposalsInType(declaration.Type, t);
			}
			
			var pit = m.Parameters.iterator();
			foreach (var p in declaration.Parameters) {
				var pt = pit.next().Type;
				
				var bounds = p.getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				if (bounds.isBeforeOffset(offset)) {
					continue;
				}
			
				if (containsOffset(p.Type)) {
					return computeCompletionProposalsInType(p.Type, pt);
				}
	
				Environment.trace(this, "indexer parameter");
				return EMPTY_PROPOSALS;
			}
			var accessor = declaration.GetAccessor;
			if (accessor != null && containsOffset(accessor)) {
				var body = accessor.Body;
				if (body != null && containsOffset(body)) {
					context.enterIndexerGetter(declaration);
					return statementProcessor.handleStatement(body, null);
				}
		
				// TODO
				Environment.trace(this, "indexer getter");
				return EMPTY_PROPOSALS;
			}
			accessor = declaration.SetAccessor;
			if (accessor != null && containsOffset(accessor)) {
				var body = accessor.Body;
				if (body != null && containsOffset(body)) {
					context.enterIndexerSetter(declaration);
					return statementProcessor.handleStatement(body, null);
				}
		
				// TODO
				Environment.trace(this, "indexer setter");
				return EMPTY_PROPOSALS;
			}
		
			// TODO
			Environment.trace(this, "indexer");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInConstructor(ConstructorDeclarationNode declaration) {
			var pit = declaration.getUserData(typeof(JvmMethodInfo)).Parameters.iterator();
			foreach (var p in declaration.Parameters) {
				var pt = pit.next().Type;
			
				var bounds = p.getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				if (bounds.isBeforeOffset(offset)) {
					continue;
				}
			
				if (containsOffset(p.Type)) {
					return computeCompletionProposalsInType(p.Type, pt);
				}
	
				Environment.trace(this, "constructor parameter");
				return EMPTY_PROPOSALS;
			}
		
			var body = declaration.Body;
			if (body != null && containsOffset(body)) {
				context.enterConstructor(declaration);
				return statementProcessor.handleStatement(body, null);
			}
			
			Environment.trace(this, "constructor");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInDestructor(DestructorDeclarationNode declaration) {
			var body = declaration.Body;
			if (body != null && containsOffset(body)) {
				return statementProcessor.handleStatement(body, null);
			}
		
			Environment.trace(this, "destructor");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInField(FieldDeclarationNode declaration) {
			var f = declaration.Declarators[0].getUserData(typeof(JvmFieldInfo));
			
			if (containsOffset(declaration.Type)) {
				return computeCompletionProposalsInType(declaration.Type, f.Type);
			}

			foreach (var decl in declaration.Declarators) {
				var bounds = decl.getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				if (bounds.isBeforeOffset(offset)) {
					expressionProcessor.handleExpression(decl.Value, null, true);
				}
				
				Environment.trace(this, "field declarator");
				return EMPTY_PROPOSALS;
			}
			
			Environment.trace(this, "field");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInEnumConstant(EnumConstantDeclarationNode declaration) {
			foreach (var e in declaration.Arguments) {
				var bounds = e.getUserData(typeof(SyntaxNodeBounds));
				if (bounds == null || bounds.isAfterOffset(offset)) {
					break;
				}
				if (bounds.isBeforeOffset(offset)) {
					continue;
				}
				return expressionProcessor.handleExpression(e, null, true);
			}
		
			Environment.trace(this, "enum constant");
			return EMPTY_PROPOSALS;
		}

		private ICompletionProposal[] computeCompletionProposalsInSimpleType(TypeReferenceNode type) {
			String prefix;
			int length;
			if (offset == token.offset) {
				var tk = tokens[tokenIndex - 1];
				length = 0;
				prefix = new String(text, tk.offset, tk.length);
			} else {
				length = token.length - (offset - token.offset);
				prefix = new String(text, token.offset, offset - token.offset);
			}
			return CompletionProposalHelper.createCompletionProposals(offset, length, prefix, context.getRootPackages(),
					context.getTypeMembers(), TYPE_TEXTS);
		}
		
		
		private ICompletionProposal[] computeCompletionProposalsInType(TypeReferenceNode type, JvmTypeInfo jvmType) {
			Environment.trace(this, "type");
			
			switch (type.TypeReferenceKind) {
			case Boolean:
			case Byte:
			case Char:
			case Double:
			case Float:
			case Int:
			case Long:
			case Short:
			case Void:
				return computeCompletionProposalsInSimpleType(type);
				
			case SimpleName:
				var simple = (SimpleNameTypeReferenceNode)type;
				var bounds = simple.getUserData(typeof(SyntaxNodeBounds));
				var nameToken = bounds.StartToken;
				if (offset <= nameToken.offset + nameToken.length) {
					return computeCompletionProposalsInSimpleType(type);
				} else {
					var ait = jvmType.GenericArguments.iterator();
					foreach (var arg in simple.TypeArguments) {
						var at = ait.next();
					
						bounds = arg.getUserData(typeof(SyntaxNodeBounds));
						if (bounds == null || bounds.isAfterOffset(offset)) {
							break;
						}
						if (bounds.isBeforeOffset(offset)) {
							continue;
						}
						return computeCompletionProposalsInType(arg, at);
					}
					break;
				}
	
			case Qualified:
				var qualified = (QualifiedTypeReferenceNode)type;
				if (containsOffset(qualified.SimpleName)) {
					String prefix;
					int length;
					if (offset == token.offset) {
						var tk = tokens[tokenIndex - 1];
						length = 0;
						prefix = new String(text, tk.offset, tk.length);
					} else {
						length = token.length - (offset - token.offset);
						prefix = new String(text, token.offset, offset - token.offset);
					}
					Iterable<MemberInfo> typeMembers;
					if (jvmType.DeclaringType == null) {
						typeMembers = context.getTypeMembers().where(p => p.Type.PackageName.equals(jvmType.PackageName));
					} else {
						typeMembers = context.getTypeMembers().where(p => p.Type.DeclaringType == jvmType.DeclaringType);
					}
					return CompletionProposalHelper.createCompletionProposals(offset, length, prefix, Query.empty<String>(),
							typeMembers, TYPE_TEXTS);
				} else if (containsOffset(qualified.EnclosingType)) {
					if (jvmType.DeclaringType != null) {
						return computeCompletionProposalsInType(qualified.EnclosingType, jvmType.DeclaringType);
					}
				}
				break;
						
			case Array:
				var arrayType = (ArrayTypeReferenceNode)type;
				if (containsOffset(arrayType.ElementType)) {
					return computeCompletionProposalsInType(arrayType.ElementType, jvmType.ElementType);
				}
				break;
				
			case LowerBoundedWildcard:
			case UpperBoundedWildcard:
				var wildcard = (WildcardTypeReferenceNode)type;
				if (containsOffset(wildcard.Bound)) {
					return computeCompletionProposalsInType(wildcard.Bound, jvmType.WildcardBound);
				}
				break;
			}
		
			return CompletionProposalHelper.createCompletionProposals(offset, 0, "", context.getRootPackages(),
					context.getTypeMembers(), TYPE_TEXTS);
		}
		
		private boolean containsOffset(SyntaxNode syntaxNode) {
			var bounds = syntaxNode.getUserData(typeof(SyntaxNodeBounds));
			if (bounds == null) {
				return false;
			}
			return bounds.containsOffset(offset);
		}
		
		private boolean editedText(SyntaxNode syntaxNode) {
			var bounds = syntaxNode.getUserData(typeof(SyntaxNodeBounds));
			var startToken = bounds.StartToken;
			var endToken = bounds.EndToken;
			return endToken.offset + endToken.length - startToken.offset != syntaxNode.EndPosition - syntaxNode.StartPosition;
		}
		
		private Token getPreviousToken(int offset) {
			int index = Highlighter.getPositionIndex(tokens, offset);
			for (int i = index - 1; i >= 0; --i) {
				var token = tokens[i];
				switch (token.LexicalUnit) {
				case Whitespace:
				case DelimitedComment:
				case SingleLineComment:
				case NewLine:
					break;
				default:
					return token;
				}
			}
			return null;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInBody(SyntaxNode syntaxNode) {
			var prefix = "";
			int length = 0;
			if (editedText(syntaxNode)) {
				int index = Highlighter.getPositionIndex(tokens, offset - 1);
				if (index != -1) {
					var token = tokens[index];
					switch (token.LexicalUnit) {
					case Identifier:
					case Keyword:
					case ContextualKeyword:
						length = token.length - (offset - token.offset);
						prefix = new String(text, token.offset, token.length);
						break;
						
					case Dot:
						
						break;
					}
				}
			}
			return CompletionProposalHelper.createCompletionProposals(offset, length, prefix, context.getRootPackages(),
					context.getMembers(), BODY_TEXTS);
		}

		private ICompletionProposal[] computeCompletionProposalsInExpression(SyntaxNode syntaxNode) {
			var prefix = "";
			int length = 0;
			if (editedText(syntaxNode)) {
				int index = Highlighter.getPositionIndex(tokens, offset - 1);
				if (index != -1) {
					var token = tokens[index];
					switch (token.LexicalUnit) {
					case Identifier:
					case Keyword:
					case ContextualKeyword:
						length = token.length - (offset - token.offset);
						prefix = new String(text, token.offset, token.length);
						break;
						
					case Dot:
						
						break;
					}
				}
			}
			return CompletionProposalHelper.createCompletionProposals(offset, length, prefix, context.getRootPackages(),
					context.getMembers(), TYPE_TEXTS);
		}
		
		private class StatementProcessor : StatementHandler<Void, ICompletionProposal[]> {
			private ContentAssistProcessor processor;
		
			StatementProcessor(ContentAssistProcessor processor)
					: super(false) {
				this.processor = processor;
			}
			
			protected override ICompletionProposal[] handleBlock(BlockStatementNode block, Void source) {
				foreach (var s in block.Statements) {
					var bounds = s.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						if (s.StatementKind == StatementKind.LocalDeclaration) {
							processor.context.declareLocals((LocalDeclarationStatementNode)s);
						}
					} else {
						return handleStatement(s, null);
					}
				}
		
				Environment.trace(this, "block");
				return processor.computeCompletionProposalsInBody(block);
			}
			
			protected override ICompletionProposal[] handleDo(DoStatementNode doStatement, Void source) {
				if (processor.containsOffset(doStatement.Statement)) {
					return handleStatement(doStatement.Statement, null);
				}
				if (processor.containsOffset(doStatement.Condition)) {
					return processor.expressionProcessor.handleExpression(doStatement.Condition, null, true);
				}
		
				Environment.trace(this, "do");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleExpression(ExpressionStatementNode expression, Void source) {
				return processor.expressionProcessor.handleExpression(expression.Expression, null, false);
			}
			
			protected override ICompletionProposal[] handleFor(ForStatementNode forStatement, Void source) {
				foreach (var s in forStatement.Initializer) {
					var bounds = s.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						if (s.StatementKind == StatementKind.LocalDeclaration) {
							processor.context.declareLocals((LocalDeclarationStatementNode)s);
						}
					} else {
						return handleStatement(s, null);
					}
				}
				if (forStatement.Condition != null && processor.containsOffset(forStatement.Condition)) {
					return processor.expressionProcessor.handleExpression(forStatement.Condition, null, true);
				}
				foreach (var s in forStatement.Iterator) {
					var bounds = s.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleStatement(s, null);
				}
				if (processor.containsOffset(forStatement.Statement)) {
					return handleStatement(forStatement.Statement, null);
				}
		
				Environment.trace(this, "for");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleForeach(ForeachStatementNode foreachStatement, Void source) {
				if (foreachStatement.Type != null && processor.containsOffset(foreachStatement.Type)) {
					var info = foreachStatement.getUserData(typeof(MemberInfo));
					return processor.computeCompletionProposalsInType(foreachStatement.Type, info.Type);
				}
				if (processor.containsOffset(foreachStatement.Source)) {
					processor.expressionProcessor.handleExpression(foreachStatement.Source, null, true);
				}
				if (processor.containsOffset(foreachStatement.Statement)) {
					return handleStatement(foreachStatement.Statement, null);
				}
		
				Environment.trace(this, "foreach");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleGoto(GotoStatementNode gotoStatement, Void source) {
				Environment.trace(this, "goto");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleGotoCase(GotoCaseStatementNode gotoCase, Void source) {
				// TODO
				Environment.trace(this, "goto case");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleIf(IfStatementNode ifStatement, Void source) {
				if (processor.containsOffset(ifStatement.Condition)) {
					return processor.expressionProcessor.handleExpression(ifStatement.Condition, null, true);
				}
				if (processor.containsOffset(ifStatement.IfTrue)) {
					return handleStatement(ifStatement.IfTrue, null);
				}
				if (ifStatement.IfFalse != null && processor.containsOffset(ifStatement.IfFalse)) {
					return handleStatement(ifStatement.IfFalse, null);
				}
		
				Environment.trace(this, "if");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleLabeled(LabeledStatementNode labeled, Void source) {
				if (processor.containsOffset(labeled.Statement)) {
					return handleStatement(labeled.Statement, null);
				}
		
				Environment.trace(this, "labeled");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleLocalDeclaration(LocalDeclarationStatementNode localDeclaration, Void source) {
				if (localDeclaration.Type != null && processor.containsOffset(localDeclaration.Type)) {
					var info = localDeclaration.getUserData(typeof(ExpressionInfo));
					return processor.computeCompletionProposalsInType(localDeclaration.Type, info.Type);
				}
				foreach (var decl in localDeclaration.Declarators) {
					if (decl.Value != null && processor.containsOffset(decl.Value)) {
						return processor.expressionProcessor.handleExpression(decl.Value, null, true);
					}
				}
		
				Environment.trace(this, "local declaration");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleReturn(ReturnStatementNode returnStatement, Void source) {
				if (returnStatement.Value != null && processor.containsOffset(returnStatement.Value)) {
					return processor.expressionProcessor.handleExpression(returnStatement.Value, null, false);
				}
		
				Environment.trace(this, "return");
				var bounds = returnStatement.getUserData(typeof(SyntaxNodeBounds));
				var startToken = bounds.StartToken;
				if (processor.offset > startToken.offset + startToken.length && processor.offset < returnStatement.EndPosition) {
					return processor.computeCompletionProposalsInExpression(returnStatement);
				}
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleSwitch(SwitchStatementNode switchStatement, Void source) {
				if (processor.containsOffset(switchStatement.Selector)) {
					return processor.expressionProcessor.handleExpression(switchStatement.Selector, null, true);
				}
				foreach (var section in switchStatement.Sections) {
					var bounds = section.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					foreach (var s in section.Statements) {
						if (processor.containsOffset(s)) {
							return handleStatement(s, null);
						}
						if (s.StatementKind == StatementKind.LocalDeclaration) {
							processor.context.declareLocals((LocalDeclarationStatementNode)s);
						}
					}
				}
		
				Environment.trace(this, "switch");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleSynchronized(SynchronizedStatementNode synchronizedStatement, Void source) {
				if (processor.containsOffset(synchronizedStatement.Lock)) {
					return processor.expressionProcessor.handleExpression(synchronizedStatement.Lock, null, true);
				}
				if (processor.containsOffset(synchronizedStatement.Statement)) {
					return handleStatement(synchronizedStatement.Statement, null);
				}
		
				Environment.trace(this, "synchronized");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleThrow(ThrowStatementNode throwStatement, Void source) {
				if (throwStatement.Exception != null && processor.containsOffset(throwStatement.Exception)) {
					return processor.expressionProcessor.handleExpression(throwStatement.Exception, null, false);
				}
		
				Environment.trace(this, "throw");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleTry(TryStatementNode tryStatement, Void source) {
				if (processor.containsOffset(tryStatement.Block)) {
					return handleBlock(tryStatement.Block, null);
				}
				foreach (var cc in tryStatement.CatchClauses) {
					var bounds = cc.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					if (cc.ExceptionType != null && processor.containsOffset(cc.ExceptionType)) {
						var t = cc.getUserData(typeof(JvmTypeInfo));
						return processor.computeCompletionProposalsInType(cc.ExceptionType, t);
					}
					if (processor.containsOffset(cc.Block)) {
						return handleBlock(cc.Block, null);
					}
				}
				if (tryStatement.Finally != null && processor.containsOffset(tryStatement.Finally)) {
					return handleBlock(tryStatement.Finally, null);
				}
		
				Environment.trace(this, "try");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleUsing(UsingStatementNode usingStatement, Void source) {
				if (processor.containsOffset(usingStatement.ResourceAcquisition)) {
					return handleStatement(usingStatement.ResourceAcquisition, null);
				}
				if (processor.containsOffset(usingStatement.Statement)) {
					return handleStatement(usingStatement.Statement, null);
				}
		
				Environment.trace(this, "using");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleWhile(WhileStatementNode whileStatement, Void source) {
				if (processor.containsOffset(whileStatement.Condition)) {
					return processor.expressionProcessor.handleExpression(whileStatement.Condition, null, true);
				}
				if (processor.containsOffset(whileStatement.Statement)) {
					return handleStatement(whileStatement.Statement, null);
				}
		
				Environment.trace(this, "while");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleYield(YieldStatementNode yield, Void source) {
				if (yield.Value != null && processor.containsOffset(yield.Value)) {
					return processor.expressionProcessor.handleExpression(yield.Value, null, false);
				}
		
				Environment.trace(this, "yield");
				var bounds = yield.getUserData(typeof(SyntaxNodeBounds));
				var startToken = bounds.StartToken;
				// TODO: skip return or break
				if (processor.offset > startToken.offset + startToken.length && processor.offset < yield.EndPosition) {
					return processor.computeCompletionProposalsInExpression(yield);
				}
				return EMPTY_PROPOSALS;
			}
		}
		
		private class ExpressionProcessor : ExpressionHandler<Void, ICompletionProposal[]> {
			private ContentAssistProcessor processor;
			
			ExpressionProcessor(ContentAssistProcessor processor)
					: super(false) {
				this.processor = processor;
			}
			
			protected override ICompletionProposal[] handleAnonymousObjectCreation(AnonymousObjectCreationExpressionNode anonymousObject,
					Void source, boolean nested) {
				foreach (var mi in anonymousObject.MemberDeclarators) {
					var bounds = mi.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					if (processor.containsOffset(mi.Value)) {
						return handleExpression(mi.Value, source, true);
					}
			
					Environment.trace(this, "member declarator");
					return EMPTY_PROPOSALS;
				}
		
				Environment.trace(this, "anonymous object");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleArrayCreation(ArrayCreationExpressionNode arrayCreation, Void source, boolean nested) {
				if (arrayCreation.Type != null && processor.containsOffset(arrayCreation.Type)) {
					var info = arrayCreation.getUserData(typeof(ExpressionInfo));
					return processor.computeCompletionProposalsInType(arrayCreation.Type, info.Type);
				}
				foreach (var e in arrayCreation.DimensionExpressions) {
					var bounds = e.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleExpression(e, source, true);
				}
				if (arrayCreation.Initializer != null && processor.containsOffset(arrayCreation.Initializer)) {
					return handleExpression(arrayCreation.Initializer, null, true);
				}
		
				Environment.trace(this, "array creation");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleArrayInitializer(ArrayInitializerExpressionNode arrayInitializer, Void source,
					boolean nested) {
				foreach (var e in arrayInitializer.Values) {
					var bounds = e.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleExpression(e, source, true);
				}
		
				Environment.trace(this, "array initializer");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleAssign(AssignExpressionNode assign, Void source, boolean nested) {
				if (processor.containsOffset(assign.Left)) {
					return handleExpression(assign.Left, null, true);
				}
				if (processor.containsOffset(assign.Right)) {
					return handleExpression(assign.Right, null, true);
				}
		
				Environment.trace(this, "assign");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleBinary(BinaryExpressionNode binary, Void source, boolean nested) {
				if (processor.containsOffset(binary.LeftOperand)) {
					return handleExpression(binary.LeftOperand, null, true);
				}
				if (processor.containsOffset(binary.RightOperand)) {
					return handleExpression(binary.RightOperand, null, true);
				}
		
				Environment.trace(this, "binary");
				return EMPTY_PROPOSALS;
			}
	
			protected override ICompletionProposal[] handleCast(CastExpressionNode cast, Void source, boolean nested) {
				if (processor.containsOffset(cast.TargetType)) {
				var info = cast.getUserData(typeof(ExpressionInfo));
					return processor.computeCompletionProposalsInType(cast.TargetType, info.Type);
				}
				if (processor.containsOffset(cast.Expression)) {
					return handleExpression(cast.Expression, null, true);
				}
		
				Environment.trace(this, "cast");
				return processor.computeCompletionProposalsInExpression(cast);
			}
			
			protected override ICompletionProposal[] handleConditional(ConditionalExpressionNode conditional, Void source, boolean nested) {
				if (processor.containsOffset(conditional.Condition)) {
					return handleExpression(conditional.Condition, null, true);
				}
				if (processor.containsOffset(conditional.IfTrue)) {
					return handleExpression(conditional.IfTrue, null, true);
				}
				if (processor.containsOffset(conditional.IfFalse)) {
					return handleExpression(conditional.IfFalse, null, true);
				}
		
				Environment.trace(this, "conditional");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleElementAccess(ElementAccessExpressionNode elementAccess, Void source, boolean nested) {
				if (processor.containsOffset(elementAccess.TargetObject)) {
					return handleExpression(elementAccess.TargetObject, null, true);
				}
				foreach (var e in elementAccess.Indexes) {
					var bounds = e.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleExpression(e, source, true);
				}
		
				Environment.trace(this, "element access");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleInvocation(InvocationExpressionNode invocation, Void source, boolean nested) {
				if (processor.containsOffset(invocation.TargetObject)) {
					return handleExpression(invocation.TargetObject, null, true);
				}
				foreach (var e in invocation.Arguments) {
					var bounds = e.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleExpression(e, source, true);
				}
		
				Environment.trace(this, "invocation");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleLambda(LambdaExpressionNode lambda, Void source, boolean nested) {
				var m = lambda.getUserData(typeof(JvmMethodInfo));
				var pit = m.Parameters.iterator();
				foreach (var p in lambda.Parameters) {
					var pt = pit.next().Type;
					
					var bounds = p.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
				
					if (p.Type != null && processor.containsOffset(p.Type)) {
						return processor.computeCompletionProposalsInType(p.Type, pt);
					}
		
					Environment.trace(this, "lambda parameter");
					return EMPTY_PROPOSALS;
				}
				
				if (processor.containsOffset(lambda.Body)) {
					return processor.statementProcessor.handleStatement(lambda.Body, null);
				}
		
				Environment.trace(this, "lambda");
				return EMPTY_PROPOSALS;
			}

			protected override ICompletionProposal[] handleLiteral(LiteralExpressionNode literal, Void source, boolean nested) {
		
				Environment.trace(this, "literal");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleMemberAccess(MemberAccessExpressionNode memberAccess, Void source, boolean nested) {
				if (processor.containsOffset(memberAccess.TargetObject)) {
					return handleExpression(memberAccess.TargetObject, null, true);
				}
				if (processor.containsOffset(memberAccess.Member)) {
					Environment.trace(this, "member access name");
					var token = processor.tokens[Highlighter.getPositionIndex(processor.tokens, processor.offset)];
					var length = token.length - (processor.offset - token.offset);
					var prefix = new String(processor.text, token.offset, processor.offset - token.offset);
					var tinfo = memberAccess.TargetObject.getUserData(typeof(ExpressionInfo));
					return CompletionProposalHelper.createCompletionProposals(processor.offset, length, prefix, Query.empty<String>(),
							processor.context.getMembers(tinfo.Type, tinfo.Member != null && tinfo.Member.MemberKind == MemberKind.Type),
							Query.empty<String>());
				}
		
				Environment.trace(this, "member access");
				var token = processor.getPreviousToken(processor.offset);
				if (token.LexicalUnit == LexicalUnit.Dot) {
					var info = memberAccess.getUserData(typeof(ExpressionInfo));
					var member = info.Member;
					if (member == null) {
						var type = info.Type;
						if (type == null) {
							// Package
						} else {
							// Type
						}
					} else {
						var tinfo = memberAccess.TargetObject.getUserData(typeof(ExpressionInfo));
						return CompletionProposalHelper.createCompletionProposals(processor.offset, 0, "", Query.empty<String>(),
								processor.context.getMembers(tinfo.Type, tinfo.Member != null && tinfo.Member.MemberKind == MemberKind.Type),
								Query.empty<String>());
					}
				}
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleObjectCreation(ObjectCreationExpressionNode objectCreation, Void source, boolean nested) {
				if (processor.containsOffset(objectCreation.Type)) {
					var info = objectCreation.getUserData(typeof(ExpressionInfo));
					return processor.computeCompletionProposalsInType(objectCreation.Type, info.Type);
				}
				foreach (var e in objectCreation.Arguments) {
					var bounds = e.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleExpression(e, source, true);
				}
				if (objectCreation.Initializer != null && processor.containsOffset(objectCreation.Initializer)) {
					return handleExpression(objectCreation.Initializer, null, true);
				}
		
				Environment.trace(this, "object creation");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleCollectionInitializer(CollectionInitializerExpressionNode initializer, Void source,
					boolean nested) {
				foreach (var e in initializer.Values.selectMany(p => p)) {
					var bounds = e.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					return handleExpression(e, source, true);
				}
		
				Environment.trace(this, "collection initializer");
				return EMPTY_PROPOSALS;
			}
			
			// TODO: handleQuery
			
			protected override ICompletionProposal[] handleObjectInitializer(ObjectInitializerExpressionNode initializer, Void source,
					boolean nested) {
				foreach (var init in initializer.getMemberInitializers()) {
					var bounds = init.getUserData(typeof(SyntaxNodeBounds));
					if (bounds == null || bounds.isAfterOffset(processor.offset)) {
						break;
					}
					if (bounds.isBeforeOffset(processor.offset)) {
						continue;
					}
					if (processor.containsOffset(init.Value)) {
						return handleExpression(init.Value, null, true);
					}
			
					Environment.trace(this, "object member initializer");
					return EMPTY_PROPOSALS;
				}
		
				Environment.trace(this, "object initializer");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleSimpleName(SimpleNameExpressionNode simpleName, Void source, boolean nested) {
		
				Environment.trace(this, "simple name");
				return EMPTY_PROPOSALS;
			}
			
	
			protected override ICompletionProposal[] handleSizeof(SizeofExpressionNode sizeofExpression, Void source, boolean nested) {
				if (processor.containsOffset(sizeofExpression.Expression)) {
					return handleExpression(sizeofExpression.Expression, null, true);
				}
		
				Environment.trace(this, "sizeof");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleSuperAccess(SuperAccessExpressionNode superAccess, Void source, boolean nested) {
		
				Environment.trace(this, "super access");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleThisAccess(ThisAccessExpressionNode thisAccess, Void source, boolean nested) {
		
				Environment.trace(this, "this access");
				return EMPTY_PROPOSALS;
			}
	
			protected override ICompletionProposal[] handleType(TypeExpressionNode type, Void source, boolean nested) {
				var info = type.getUserData(typeof(ExpressionInfo));
				return processor.computeCompletionProposalsInType(type.TypeReference, info.Type);
			}
			
			protected override ICompletionProposal[] handleTypeof(TypeofExpressionNode typeofExpression, Void source, boolean nested) {
				if (processor.containsOffset(typeofExpression.Type)) {
					return processor.computeCompletionProposalsInType(typeofExpression.Type, typeofExpression.getUserData(typeof(JvmTypeInfo)));
				}
		
				Environment.trace(this, "typeof");
				return EMPTY_PROPOSALS;
			}
			
			protected override ICompletionProposal[] handleUnary(UnaryExpressionNode unary, Void source, boolean nested) {
				if (processor.containsOffset(unary.Operand)) {
					return handleExpression(unary.Operand, null, true);
				}
		
				Environment.trace(this, "unary");
				return EMPTY_PROPOSALS;
			}
		}
	}
}
