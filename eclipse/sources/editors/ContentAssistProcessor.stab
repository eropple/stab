/*
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 */
using java.lang;
using java.util;
using org.eclipse.jface.text;
using org.eclipse.jface.text.contentassist;
using org.eclipse.jface.text.source;
using stab.query;
using stab.tools.helpers;
using stab.tools.parser;
using stab.tools.syntaxtree;

package stab.tools.eclipse.editors {

	public class ContentAssistProcessor : IContentAssistProcessor {
		private static final ICompletionProposal[] EMPTY_PROPOSALS = CompletionProposalHelper.createEmpty();
	
		private SourceEditor editor;
		private ISourceViewer sourceViewer;
		
		private int offset;
		private int tokenIndex;
		private Token token;
		private List<Token> tokens;
		private ContentAssistContext context;

		public ContentAssistProcessor(SourceEditor editor, ISourceViewer sourceViewer) {
			this.editor = editor;
			this.sourceViewer = sourceViewer;
		}
		
		public IContextInformation[] computeContextInformation(ITextViewer viewer, int offset) {
			return null;
		}
		
		public char[] getContextInformationAutoActivationCharacters() {
			return null;
		}
	
		public String getErrorMessage() {
			return null;
		}
		
		public IContextInformationValidator getContextInformationValidator() {
			return null;
		}
		
		public char[] getCompletionProposalAutoActivationCharacters() {
			return new[] { '.' };
		}
		
		public ICompletionProposal[] computeCompletionProposals(ITextViewer viewer, int offset) {
			Environment.trace(this, "compute completion");
			var t0 = System.nanoTime();

			var file = editor.getFile();
			if (file == null) {
				Environment.trace(this, "no file");
				return EMPTY_PROPOSALS;
			}
			
			var projectManager = Environment.getProjectManager(file);
			if (projectManager == null) {
				Environment.trace(this, "not a project with Stab nature");
				return EMPTY_PROPOSALS;
			}
			
			var highlighter = editor.Highlighter;
			if (highlighter == null) {
				Environment.trace(this, "no highlighter");
				return EMPTY_PROPOSALS;
			}
			
			var tokens = highlighter.Tokens;
			if (tokens == null || tokens.size() == 0) {
				Environment.trace(this, "no tokens");
				return EMPTY_PROPOSALS;
			}
			
			var tokenIndex = Highlighter.getPositionIndex(tokens, offset);
			if (tokenIndex == -1) {
				Environment.trace(this, "no token at " + offset);
				return EMPTY_PROPOSALS;
			}

			var token = tokens[tokenIndex];
			var beforeToken = token.offset == offset;

			Environment.trace(this, "token " + token.LexicalUnit);
			
			if (token.SemanticStyle != null && !beforeToken) {
				switch (token.SemanticStyle) {
				case Preprocessor:
				case SkippedSource:
					Environment.trace(this, "in preprocessor part");
					return EMPTY_PROPOSALS;
				case DelimitedComment:
				case SingleLineComment:
					Environment.trace(this, "in comment");
					return EMPTY_PROPOSALS;
				}
			}
			if (token.LexicalUnit == LexicalUnit.NewLine) {
				if (tokenIndex > 0 && tokens[tokenIndex - 1].LexicalUnit == LexicalUnit.SingleLineComment) {
					Environment.trace(this, "in comment");
					return EMPTY_PROPOSALS;
				}
			}

			var compilationUnit = highlighter.CompilationUnit;
			if (compilationUnit == null) {
				Environment.trace(this, "no AST");
				return EMPTY_PROPOSALS;
			}

			this.offset = offset;
			this.tokenIndex = tokenIndex;
			this.token = token;
			this.tokens = tokens;
			this.context = new ContentAssistContext();

			var result = computeCompletionProposalsInPackage(compilationUnit.Body);
			Environment.trace(this, "compute completion done in " + ((System.nanoTime() - t0) / 1e6) + "ms");
			return result;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInPackage(PackageBodyNode body) {
			if (body != null) {
				try {
					context.enterPackage(body);
					foreach (var m in body.Members) {
						var it = ((UserDataContainer)m).getAllUserData(typeof(Token)).iterator();
						var startToken = it.next();
						var endToken = it.next();
						if (startToken.offset >= offset) {
							break;
						}
						if (endToken.offset + endToken.length <= offset) {
							continue;
						}
						switch (m.PackageMemberKind) {
						case Package:
							return computeCompletionProposalsInPackage(((PackageDeclarationNode)m).Body);
						case Class:
							return computeCompletionProposalsInClass((ClassDeclarationNode)m);
						case Interface:
							return computeCompletionProposalsInInterface((InterfaceDeclarationNode)m);
						case Delegate:
							return computeCompletionProposalsInDelegate((DelegateDeclarationNode)m);
						}
					}
				} finally {
					context.leavePackage();
				}
			}
			// TODO
			Environment.trace(this, "package");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInClass(ClassDeclarationNode declaration) {
			try {
				context.enterClass(declaration);
				foreach (var m in declaration.Members) {
					var it = ((UserDataContainer)m).getAllUserData(typeof(Token)).iterator();
					var startToken = it.next();
					var endToken = it.next();
					if (startToken.offset >= offset) {
						break;
					}
					if (endToken.offset + endToken.length <= offset) {
						continue;
					}
					switch (m.TypeMemberKind) {
					case Class:
						return computeCompletionProposalsInClass((ClassDeclarationNode)m);
					case Interface:
						return computeCompletionProposalsInInterface((InterfaceDeclarationNode)m);
					case Delegate:
						return computeCompletionProposalsInDelegate((DelegateDeclarationNode)m);
					case Method:
						return computeCompletionProposalsInMethod((MethodDeclarationNode)m);
					case Property:
						return computeCompletionProposalsInProperty((PropertyDeclarationNode)m);
					case Indexer:
						return computeCompletionProposalsInIndexer((IndexerDeclarationNode)m);
					case Constructor:
						return computeCompletionProposalsInConstructor((ConstructorDeclarationNode)m);
					case Destructor:
						return computeCompletionProposalsInDestructor((DestructorDeclarationNode)m);
					case Field:
						return computeCompletionProposalsInField((FieldDeclarationNode)m);
					case EnumConstant:
						return computeCompletionProposalsInEnumConstant((EnumConstantDeclarationNode)m);
					}
				}
			} finally {
				context.leaveClass();
			}
			// TODO
			Environment.trace(this, "class");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInInterface(InterfaceDeclarationNode declaration) {
			try {
				context.enterInterface(declaration);
				foreach (var m in declaration.Members) {
					var it = ((UserDataContainer)m).getAllUserData(typeof(Token)).iterator();
					var startToken = it.next();
					var endToken = it.next();
					if (startToken.offset >= offset) {
						break;
					}
					if (endToken.offset + endToken.length <= offset) {
						continue;
					}
					switch (m.TypeMemberKind) {
					case Method:
						return computeCompletionProposalsInMethod((MethodDeclarationNode)m);
					case Property:
						return computeCompletionProposalsInProperty((PropertyDeclarationNode)m);
					case Indexer:
						return computeCompletionProposalsInIndexer((IndexerDeclarationNode)m);
					}
				}
			} finally {
				context.leaveInterface();
			}
			// TODO
			Environment.trace(this, "interface");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInDelegate(DelegateDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "delegate");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInMethod(MethodDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "method");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInProperty(PropertyDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "property");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInIndexer(IndexerDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "indexer");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInConstructor(ConstructorDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "constructor");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInDestructor(DestructorDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "destructor");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInField(FieldDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "field");
			return EMPTY_PROPOSALS;
		}
		
		private ICompletionProposal[] computeCompletionProposalsInEnumConstant(EnumConstantDeclarationNode declaration) {
		
			// TODO
			Environment.trace(this, "enum constant");
			return EMPTY_PROPOSALS;
		}
	}
}
